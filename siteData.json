[
	"\n  \tAn introduction and overview of the D3.js data visualisation library.\n\nD3 is a JavaScript library used to create bespoke, interactive charts and maps on the web.\n\nMost charting libraries (such as Chart.js and Highcharts) provide ready made charts whereas D3 consists of building blocks with which custom charts or maps can be constructed.\n\nD3’s approach is much lower level than other charting libraries. Creating a bar chart with Chart.js is just a few lines of code.\n\n\n\nCreating a similar chart with D3 is more involved and requires experience with JavaScript, HTML, SVG and CSS.\n\nIf you require a standard bar, line or pie chart you should consider a library such as Chart.js. However if you require bespoke charts or have very precise needs then D3 should be considered.\n\nD3’s features include:\n\n\n  data-driven modification of HTML and SVG elements\n  scale functions\n  loading and transforming data (e.g. CSV data)\n  helpers for generating complex charts such as treemaps, packed circles and networks\n  a powerful transition system for animating between different chart states\n  powerful user interaction support, including panning, zooming and dragging\n\n\nLet’s look at each of these in turn.\n\nData-driven modification of HTML/SVG elements\n\nD3 lets you add, remove and modify HTML and SVG elements in a data-driven fashion.\n\nFor example, suppose you have an array of numbers. You can ask D3 to create an SVG circle for each array element.\n\nFurthermore you can ask D3 to set the radius of each circle according to each array value. This is known as data binding (or joining) and is a cornerstone of D3.\n\nWe cover these aspects in the Selections, Joins and Enter/Exit chapters.\n\nScale functions\n\nScale functions take an input (usually a number, string or date) and return a value (usually a number or a string).\n\nThey’re typically used to transform (or ‘map’) data values into visual values (such as position, length and colour).\n\nFor example, they can be used to transform your data values into positions on the screen.\n\nScale functions are covered in the Scale functions chapter.\n\nLoading and transforming data\n\nOne of the most common data formats is comma separated value (CSV). This format is easily exportable by spreadsheets and databases, is human readable and is relatively compact.\n\nD3 can help you request CSV files from a given URL and to convert the CSV file into a JavaScript array. This makes working with real data much easier.\n\nWe cover loading CSV files in the Requests chapter.\n\nComplex chart creation\n\nD3 provides building blocks for creating more complex charts such as treemaps, packed circles, network graphs and geographic maps.\n\nFor example, to create a packed circle chart you can use D3’s pack layout which, given a tree data structure, appends position and size values to each item in the tree.\n\nYou can then use a D3 data join to create an SVG circle for each tree item. Each circle can then be positioned and sized according to the values calculated by the pack layout.\n\n\n\nWe cover the creation of more complex shapes and charts in the Shapes, Layouts, Force and Geographic chapters.\n\nTransitions\n\nD3 transitions let you smoothly animate between different chart states. For instance, if you have a scatter plot and the user selects a different indicator for one of the axes, the points will smoothly animate to their new positions.\n\n\n\nAs well as being visually appealing, the transition helps you track the movement of the points.\n\nD3’s transition system is powerful (it lets you control how elements first appear, how they move to new states, and how they exit the page) and is relatively simple to use.\n\nWe cover D3 transitions in the Transitions chapter.\n\nAdvanced interaction support\n\nWhen the entire contents of a chart or map can’t comfortably fit within a given window, user interaction such as panning and zooming can help.\n\nD3 can help you add panning and zooming to a chart, saving you a lot of work (especially checking it works on all platforms).\n\nWe cover advanced interactions in the Interaction chapter.\n\nWhere next?\n\nUnless you’re here for a specific topic, I suggest starting with the Selections, Joins, Enter/exit and Scales chapters.\n\nOnce you’re comfortable with those, browse through the remaining chapters and choose whichever appeals the most!\n\n\n  ",
	"\n  \tGetting started with D3.js. This article assumes familiarity with HTML, SVG, CSS and JavaScript.\n\nD3 in Depth assumes you’re familiar with HTML, SVG, CSS and JavaScript. If not, I recommend reading Fundamentals of HTML, SVG, CSS and JavaScript for Data Visualisation.\n\nIf you’re familiar with libraries such as React and Vue.js (or even jQuery) you should be fine.\n\nThere are many code examples hosted on CodePen. For example:\n\n\n\n\n\n\n  \n\n\nClicking on the ‘Edit in CodePen’ button opens the example in CodePen.\n\nEach example consists of three or more files:\n\n\n  index.html\n  index.js\n  style.css\n\n\nindex.html will usually look something like:\n\n<svg width=\"760\" height=\"140\">\n  <g transform=\"translate(70, 70)\">\n  </g>\n</svg>\n\n\n(CodePen hides the usual boilerplate that starts <!DOCTYPE html> and ends </html>.)\n\nindex.js contains your JavaScript code and is automatically included into index.html by CodePen. (I’ve also configured the examples to include D3.js.)\n\nstyle.css contains your CSS code and is also automatically included into index.html by CodePen.\n\nExporting from CodePen\n\nCodePen has a nice feature where you can download the pen and work on it in your own code editor. You first need to save the pen then some buttons will appear in the bottom right. Click on Export and choose the Export as .zip option. This will result in a folder containing your code.\n\nThe src directory contains the code as it appears in the pen and is perhaps not so useful. The dist directory however has the complete code and can be edited locally, served locally (or uploaded to the web).\n\nIf any of this doesn’t make sense to you I suggest reading Fundamentals of HTML, SVG, CSS and JavaScript for Data Visualisation course which goes into more detail.\n\n\n  ",
	"\n  \tHow to select HTML and SVG elements using D3 selections. This article shows how to select, insert, remove and modify elements, how to add event handlers, how to apply a function to selections and how to filter and sort selections.\n\nD3 selections let you choose some HTML or SVG elements and change their style and/or attributes.\n\nFor example, if your index.html file contains 5 SVG circle elements:\n\n<svg width=\"760\" height=\"140\">\n  <g transform=\"translate(70, 70)\">\n    <circle/>\n    <circle cx=\"120\" />\n    <circle cx=\"240\" />\n    <circle cx=\"360\" />\n    <circle cx=\"480\" />\n  </g>\n</svg>\n\nyou can use d3.selectAll to select the circles then .style to change their fill and .attr to change their radius:\n\nd3.selectAll('circle')\n  .style('fill', 'orange')\n  .attr('r', function() {\n    return 10 + Math.random() * 40;\n  });\n\n\n\n\n\n\n  \n\n\nD3 selections also let you perform data joins (see the Data Joins chapter).\n\nMaking selections\n\nD3 has two functions to make selections d3.select and d3.selectAll.\n\nd3.select selects the first matching element whilst d3.selectAll selects all matching elements.\n\nBoth functions take a string as its only argument. The string specifies which elements to select and is in the form of a CSS selector string (e.g. div.item, #my-chart or g:first-child).\n\nFor example to select all elements with class item use d3.selectAll('.item').\n\n(If you’re not familiar with CSS selectors take a look at the CSS section in my free Fundamentals of HTML, SVG, CSS and JavaScript for Data Visualization course.)\n\nModifying elements\n\nOnce you’ve made a selection you can modify the elements in it using the following functions:\n\n\n\t\n\t\tNameBehaviourExample\n\t\n\t\n\t\t.styleUpdate the styled3.selectAll('circle').style('fill', 'red')\n\t\n\t\n\t\t.attrUpdate an attributed3.selectAll('rect').attr('width', 10)\n\t\n\t\n\t\t.classedAdd/remove a class attributed3.select('.item').classed('selected', true)\n\t\n\t\n\t\t.propertyUpdate an element's propertyd3.selectAll('.checkbox').property('checked', false)\n\t\n\t\n\t\t.textUpdate the text contentd3.select('div.title').text('My new book')\n\t\n\t\n\t\t.htmlChange the html contentd3.select('.legend').html('<div class=\"block\"></div><div>0 - 10</div>')\n\t\n\n\n\n\nWhether .select or .selectAll is used, all elements in the selection will be modified.\n\nNote that the second argument of .classed is a boolean. I often forget to include true or false and it raises an non-obvious error message!\n\nHere’s an example of all of these functions in use:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nUpdating selections with functions\n\nIn addition to passing constant values to .style, .attr, .classed, .property, .text and .html you can pass in a function. For example:\n\nd3.selectAll('circle')\n  .attr('cx', function(d, i) {\n    return i * 100;\n  });\n\nThe function accepts two arguments which are usually named d and i. The first argument d is the joined data (or ‘datum’) and will be covered in the data joins chapter. i is the index of the element within the selection.\n\nIf you want to update elements in a selection according to their position within the selection, you can use the i argument. For example to position some rect elements horizontally you can use:\n\nd3.selectAll('rect')\n  .attr('x', function(d, i) {\n    return i * 40;\n  });\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nIn the majority of cases when functions are passed in, anonymous functions are used. However you can also use named functions. For example:\n\nfunction positionRects(d, i) {\n  return i * 40;\n}\n\nd3.selectAll('rect')\n  .attr('x', positionRects);\n\nEvent handling\n\nYou can add event handlers to selected elements using the .on method.\n\nThis method has two arguments:\n\n\n  \n    the first is a string specifying the event type\n  \n  \n    the second is a function (a ‘callback function’) that’s called when the event is triggered. This callback function has two arguments that are usually named e and d. e is the DOM event object and d is the joined data (which will be covered in the data joins chapter).\n  \n\n\nUp to and including D3 version 5, the callback function was passed the datum d and index i. This is a breaking change.\n\nThe most common events include (see MDN event reference for more details):\n\n\n\t\n\t\tEvent nameDescription\n\t\n\t\n\t\tclickElement has been clicked\n\t\n\t\n\t\tmouseenterMouse pointer has moved onto the element\n\t\n\t\n\t\tmouseoverMouse pointer has moved onto the element or its children\n\t\n\t\n\t\tmouseleaveMouse pointer has moved off the element\n\t\n\t\n\t\tmouseoutMouse pointer has moved off the element or its children\n\t\n\t\n\t\tmousemoveMouse pointer has moved over the element\n\t\n\n\nIn the event callback function the this variable is bound to the DOM element that triggered the event. This allows us to do things such as:\n\nd3.selectAll('circle')\n  .on('click', function(e, d) {\n    d3.select(this)\n      .style('fill', 'orange');\n  });\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nNote that this is a DOM element and not a D3 selection so if you wish to modify it using D3 you must first select it using d3.select(this).\n\nInserting and removing elements\n\nElements can be added to a selection’s elements using D3’s .append and .insert methods. Elements can be removed using .remove.\n\n.append appends an element to each element in a selection. If the elements already have children, the new element will become the last child. The first argument specifies the type of element.\n\nAs an example let’s start with 3 g elements, each containing a circle:\n\n<g class=\"item\" transform=\"translate(0, 0)\">\n  <circle r=\"40\" />\n</g>\n<g class=\"item\" transform=\"translate(120, 0)\">\n  <circle r=\"40\" />\n</g>\n<g class=\"item\" transform=\"translate(240, 0)\">\n  <circle r=\"40\" />\n</g>\n\nYou can append a text element to each using:\n\nd3.selectAll('g.item')\n  .append('text')\n  .text('A');\n\nresulting in a text element being added to each g.item:\n\n<g class=\"item\" transform=\"translate(0, 0)\">\n  <circle r=\"40\" />\n  <text>A</text>\n</g>\n<g class=\"item\" transform=\"translate(120, 0)\">\n  <circle r=\"40\" />\n  <text>A</text>\n</g>\n<g class=\"item\" transform=\"translate(240, 0)\">\n  <circle r=\"40\" />\n  <text>A</text>\n</g>\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n.insert is similar to .append but it allows us to specify a second argument which specifies (as a CSS selector) which element to insert the new element before.\n\nIn this example, .insert is used and the second argument is 'circle':\n\nd3.selectAll('g.item')\n  .insert('text', 'circle')\n  .text('A');\n\nThis results in the text element being inserted before the circle:\n\n<g class=\"item\" transform=\"translate(0, 0)\">\n  <text>A</text>\n  <circle r=\"40\" />\n</g>\n<g class=\"item\" transform=\"translate(120, 0)\">\n  <text>A</text>\n  <circle r=\"40\" />\n</g>\n<g class=\"item\" transform=\"translate(240, 0)\">\n  <text>A</text>\n  <circle r=\"40\" />\n</g>\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n.remove removes all the elements in a selection from the page. For example, given some circles, you can remove them using:\n\nd3.selectAll('circle')\n  .remove();\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nChaining\n\nThe return value of most selection methods is the selection itself. This means that selection methods such as .style, .attr and .on can be chained. For example:\n\nd3.selectAll('circle')\n  .style('fill', '#333')\n  .attr('r', 20)\n  .on('click', function(d, i) {\n    d3.select(this)\n      .style('fill', 'orange');\n  });\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n.each()\n\nThe .each method lets you call a function for each element of a selection.\n\nThe callback function has two arguments usually named d and i. The first argument d is the joined data (or ‘datum’) and will be covered in the data joins chapter. i is the index of the element within the selection. The this keyword refers to the current HTML or SVG element in the selection.\n\nHere’s an example where .each is used to call a function for each of the selection’s elements. The function computes whether the index is odd or even and modifies the circle accordingly:\n\nd3.selectAll('circle')\n  .each(function(d, i) {\n    var odd = i % 2 === 1;\n\n    d3.select(this)\n      .style('fill', odd ? 'orange' : '#ddd')\n      .attr('r', odd ? 40 : 20);\n  });\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nNote that this refers to the current HTML or SVG element (or the ith element in the selection). If you wish to modify it using D3 you can select it using d3.select(this).\n\n.call()\n\nThe .call method allows a function to be called into which the selection itself is passed as the first argument.\n\n.call is useful where you want a reusable function that operates on a selection.\n\nFor example, colorAll takes a selection and sets the fill of the selection’s elements to orange:\n\nfunction colorAll(selection) {\n  selection\n    .style('fill', 'orange');\n}\n\nd3.selectAll('circle')\n  .call(colorAll);\n\n\n\n\n\n\n  \n\n\nFiltering and sorting selections\n\nYou can filter a selection using D3’s .filter method. The first argument is a function which returns true if the element should be included. The filtered selection is returned by the filter method so you can continue chaining selection methods.\n\nIn this example you filter through even-numbered elements and colour them orange:\n\nd3.selectAll('circle')\n  .filter(function(d, i) {\n    return i % 2 === 0;\n  })\n  .style('fill', 'orange');\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nSorting only really makes sense if data has been joined to the selection, so please read up on data joins first.\n\nYou can sort elements in a selection by calling .sort and passing in a comparator function. The comparator function has two arguments, usually a and b, which represent the datums on the two elements being compared. If the comparator function returns a negative number, a will be placed before b and if positive, a will be placed after b.\n\nThus if you have the following data joined to a selection:\n\n[\n  {\n    \"name\": \"Andy\",\n    \"score\": 37\n  },\n  {\n    \"name\": \"Beth\",\n    \"score\": 39\n  },\n  {\n    \"name\": \"Craig\",\n    \"score\": 31\n  },\n  {\n    \"name\": \"Diane\",\n    \"score\": 35\n  },\n  {\n    \"name\": \"Evelyn\",\n    \"score\": 38\n  }\n]\n\nyou can sort by score using:\n\n  d3.selectAll('.person')\n    .sort(function(a, b) {\n      return b.score - a.score;\n    });\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n\n  ",
	"\n  \tThis article shows how to join an array of data to a D3 selection. We cover how to create a data join, how to update a data join, how to join an array of objects and key functions. We also show how to simplify your data join code using layout functions.\n\nA data join creates a correspondence between an array of data and a selection of HTML or SVG elements.\n\nJoining an array to HTML/SVG elements means that:\n\n\n  HTML (or SVG) elements are added or removed such that each array element has a corresponding HTML (or SVG) element\n  each HTML/SVG element may be positioned, sized and styled according to the value of its corresponding array element\n\n\nFor example, suppose you’ve an array of five numbers which you’d like to join to circle elements:\n\n[ 40, 10, 20, 60, 30 ]\n\nEach time D3 performs the join it’ll add or remove circle elements so that each array element has a corresponding circle element.\n\nD3 can also update the position and radius of each circle (and any other attributes or style) based on the value of the corresponding array element.\n\nFor example, the radius of each circle can be set to half the value of the corresponding array value. This results in the first circle having a radius of 20, the second a radius of 5 and so on:\n\n\n\n\n\n\n  \n\n\nPrior to version 5 of D3, data joins were not all that easy to learn (you had to learn about enter, exit and update). Fortunately, for versions 5 and up, data joins are much easier!\n\nHow to create a data join\n\nThe general pattern for creating a data join is:\n\nd3.select(container)\n  .selectAll(element-type)\n  .data(array)\n  .join(element-type);\n\nwhere:\n\n\n  container is a CSS selector string that specifies a single element that’ll contain the joined HTML/SVG elements\n  element-type is a string describing the type of element you’re joining (e.g. ‘div’ or ‘circle’)\n  array is the name of the array you’re joining\n\n\nTypically four methods are used in a data join:\n\n\n  .select defines the element that’ll act as a container (or parent) to the joined HTML/SVG elements\n  .selectAll defines the type of element that’ll be joined to each array element\n  .data defines the array that’s being joined\n  .join performs the join. This is where HTML or SVG elements are added and removed\n\n\nExample\n\nGiven an array:\n\nlet myData = [40, 10, 20, 60, 30];\n\nand an svg element containing a g element:\n\n<svg>\n  <g class=\"chart\">\n  </g>\n</svg>\n\nyou can join myData to circle elements using:\n\nlet myData = [40, 10, 20, 60, 30];\n\nd3.select('.chart')\n  .selectAll('circle')\n  .data(myData)\n  .join('circle');\n\nIn this example:\n\n\n  the container is the g element\n  the element type is circle\n  the array being joined is myData\n\n\nRunning this code results in 5 circles being created:\n\n<svg>\n  <g class=\"chart\">\n    <circle></circle>\n    <circle></circle>\n    <circle></circle>\n    <circle></circle>\n    <circle></circle>\n  </g>\n</svg>\n\n\n\n\n\n\n  \n\n\nYou can’t see any circles because each radius is zero. However if you inspect and expand the SVG element (right click on the SVG element which has been coloured light pink and select Inspect) you’ll see five circle elements have been added:\n\n\n\nIn the CodePen example you can try adding elements to the array and you’ll see that the data join ensures there are as many circles as array elements.\n\nUpdating the joined elements\n\nJoined HTML or SVG elements may be updated using the .style, .attr and .text methods that were covered in the selections chapter. (The .join method returns a selection containing all of the joined elements.)\n\nFor example you can set the center, radius and colour of every circle using:\n\nlet myData = [40, 10, 20, 60, 30];\n\nd3.select('.chart')\n  .selectAll('circle')\n  .data(myData)\n  .join('circle')\n  .attr('cx', 200)\n  .attr('cy', 50)\n  .attr('r', 40)\n  .style('fill', 'orange');\n\n\n\n\n\n\n  \n\n\nYou only see one circle because all five circles share the same position and size.\n\nData driven updates\n\nIf a function is passed into .attr or .style you can update the HTML/SVG elements in a data-driven manner.\n\nThe function is called for each element in the selection. It takes two parameters, typically named d and i.\n\nThe first parameter (d) represents the corresponding array element (or the ‘joined value’). The second parameter i represents the index of the element within the selection.\n\nThe return value of the function is used to set the attribute or style value.\n\nLet’s pass a function into the first .attr:\n\nlet myData = [40, 10, 20, 60, 30];\n\nd3.select('.chart')\n  .selectAll('circle')\n  .data(myData)\n  .join('circle')\n  .attr('cx', function(d, i) {\n    return i * 100;\n  })\n  .attr('cy', 50)\n  .attr('r', 40)\n  .style('fill', 'orange');\n\nThis tells D3 to set each circle’s cx attribute to i * 100. i is the index within the selection, so the first circle will be positioned at 0, the next at 100 and so on:\n\n\n\n\n\n\n  \n\n\nNow let’s set r according to the joined value:\n\nlet myData = [40, 10, 20, 60, 30];\n\nd3.select('.chart')\n  .selectAll('circle')\n  .data(myData)\n  .join('circle')\n  .attr('cx', function(d, i) {\n    return i * 100;\n  })\n  .attr('cy', 50)\n  .attr('r', function(d) {\n    return 0.5 * d;\n  })\n  .style('fill', 'orange');\n\n\n\n\n\n\n  \n\n\n(The first circle is clipped because it’s cx attribute is zero.)\n\nYou can put any amount of logic within the functions that are passed into .attr and .style. For example, let’s colour the circle if its joined value is greater than 30:\n\nlet myData = [40, 10, 20, 60, 30];\n\nd3.select('.chart')\n  .selectAll('circle')\n  .data(myData)\n  .join('circle')\n  .attr('cx', function(d, i) {\n    return i * 100;\n  })\n  .attr('cy', 50)\n  .attr('r', function(d) {\n    return 0.5 * d;\n  })\n  .style('fill', function(d) {\n    return d > 30 ? 'orange' : '#eee';\n  });\n\n\n\n\n\n\n  \n\n\nThe .join method returns a D3 selection, so you can use any of the methods covered in the selections chapter such as .style, .attr, .text and .each\n\nJoining arrays of objects\n\nWhen building data visualisations with D3 you’ll typically be joining arrays of objects (rather than arrays of numbers). For example:\n\nlet cities = [\n  { name: 'London', population: 8674000},\n  { name: 'New York', population: 8406000},\n  { name: 'Sydney', population: 4293000},\n  { name: 'Paris', population: 2244000},\n  { name: 'Beijing', population: 11510000}\n];\n\nYou can join an array of objects in the same manner as before. However, when a function is passed into .attr or .style, the d parameter is an object. This means that you’ll typically reference a property of that object.\n\nFor example:\n\n  ...\n  .attr('r', function(d) {\n    return 0.0001 * d.population;\n  })\n  ...\n\nHere’s a full example where cities is joined to circle elements:\n\nvar cities = [\n  { name: 'London', population: 8674000},\n  { name: 'New York', population: 8406000},\n  { name: 'Sydney', population: 4293000},\n  { name: 'Paris', population: 2244000},\n  { name: 'Beijing', population: 11510000}\n];\n\nd3.select('.chart')\n  .selectAll('circle')\n  .data(cities)\n  .join('circle')\n  .attr('cx', function(d, i) {\n    return i * 100;\n  })\n  .attr('cy', 50)\n  .attr('r', function(d) {\n    let scaleFactor = 0.00004;\n    return scaleFactor * d.population;\n  })\n  .style('fill', '#aaa');\n\n\n\n\n\n\n  \n\n\nEach circle is sized according to the city’s population. (Note that it’s better practice to set the area, rather than the radius, of a circle proportionally to a data value.)\n\nYou can build a simple bar chart using the above techniques. Instead of joining circle elements, let’s join rect and text elements:\n\nlet cities = [\n  { name: 'London', population: 8674000},\n  { name: 'New York', population: 8406000},\n  { name: 'Sydney', population: 4293000},\n  { name: 'Paris', population: 2244000},\n  { name: 'Beijing', population: 11510000}\n];\n\n// Join cities to rect elements and modify height, width and position\nd3.select('.bars')\n  .selectAll('rect')\n  .data(cities)\n  .join('rect')\n  .attr('height', 19)\n  .attr('width', function(d) {\n    let scaleFactor = 0.00004;\n    return d.population * scaleFactor;\n  })\n  .attr('y', function(d, i) {\n    return i * 20;\n  })\n\n// Join cities to text elements and modify content and position\nd3.select('.labels')\n  .selectAll('text')\n  .data(cities)\n  .join('text')\n  .attr('y', function(d, i) {\n    return i * 20 + 13;\n  })\n  .text(function(d) {\n    return d.name;\n  });\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nHow about that? We’ve just built a simple bar chart using D3!\n\n(This example relies on extra code in index.html and style.css. Open the CodePen example to see the full example.)\n\nUpdate functions\n\nIf your data array changes you’ll need to perform the join again. (Unlike some frameworks such as Vue.js, D3 doesn’t automatically do this for you.)\n\nTherefore we usually put the join code in a function. Whenever the data changes, we’ll call this function.\n\nI usually name the function update. For example:\n\nlet myData = [40, 10, 20, 60, 30];\n\nfunction update(data) {\n  d3.select('.chart')\n    .selectAll('circle')\n    .data(data)\n    .join('circle')\n    .attr('cx', function(d, i) {\n      return i * 100;\n    })\n    .attr('cy', 50)\n    .attr('r', function(d) {\n      return 0.5 * d;\n    })\n    .style('fill', function(d) {\n      return d > 30 ? 'orange' : '#eee';\n    });\n}\n\nupdate(myData);\n\n\n\n\n\n\n  \n\n\nWe pass the data array into update. Each time update is called the join is performed.\n\nThe data doesn’t ever change in the previous example, so let’s add a button that when clicked gets some randomised data and calls update:\n\nfunction getData() {\n  let data = [];\n  let numItems = Math.ceil(Math.random() * 5);\n\n  for(let i=0; i<numItems; i++) {\n    data.push(Math.random() * 60);\n  }\n\n  return data;\n}\n\nfunction update(data) {\n  d3.select('.chart')\n    .selectAll('circle')\n    .data(data)\n    .join('circle')\n    .attr('cx', function(d, i) {\n      return i * 100;\n    })\n    .attr('cy', 50)\n    .attr('r', function(d) {\n      return 0.5 * d;\n    })\n    .style('fill', function(d) {\n      return d > 30 ? 'orange' : '#eee';\n    });\n}\n\nfunction updateAll() {\n  let myData = getData();\n  update(myData);\n}\n\nupdateAll();\n\nd3.select(\"button\")\n  .on(\"click\", updateAll);\n\n\n\n\n\n\n  \n\n\ngetData returns an array containing a random number of random values. A button element has been added to index.html (see the CodePen example). The last two lines add an event handler updateAll to this button. updateAll calls getData and then calls update to perform the join.\n\nTherefore each time the button is clicked, the data updates and the circles update accordingly.\n\nKey functions\n\nWhen D3 performs a data join it joins the first array element to the first element in the selection, the second array element to the second element in the selection and so on.\n\nHowever, if the order of array elements changes (due to sorting, inserting or removing elements) the array elements can get joined to different DOM elements.\n\nYou can ensure each array element remains joined to the same HTML/SVG element by passing a key function into the .data method. The key function should return a unique id value for each array element.\n\nLook at this example where an array ['Z'] is joined to div elements. Each time the button is clicked a new letter is added to the start of the array:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nWhen ‘Insert element’ is clicked a new div element is added to the end of the row. However, the text of each existing div changes, resulting in a rather strange effect.\n\nIf a key function is used, each letter will stay joined to the same div element:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nIn general, if your array elements can change position within the array you should probably use a key function.\n\nDebugging\n\nWhen D3 performs a data join it adds an attribute __data__ to each DOM element in the selection and assigns the joined data to it.\n\nWe can inspect this in Google Chrome by right clicking on an element, choosing ‘Inspect’ and typing:\n\n$0.__data__\n\nin the debug console. ($0 represents the element that’s being inspected.)\n\n\n\nBeing able to check the joined data in this manner is particularly useful when debugging as it allows us to check whether our data join is behaving as expected.\n\n\n  ",
	"\n  \tThis article shows how D3’s enter and exit methods can be used to achieve fine grained control over the behaviour of entering and exiting elements. This is particularly useful when dealing with transitioning elements.\n\nThis chapter explains how you can gain extra control over how HTML and SVG elements behave when they are created, updated or removed. It’s particularly relevant when you’re using transitions and want particular effects (such as elements fading in and out).\n\nIf you’re new to D3 you can safely skip this chapter!\n\nThe examples in the data joins chapter update the HTML/SVG elements in the same manner, regardless of whether they’ve just been created, are already on the page or are about to be removed.\n\n(HTML/SVG elements that have just been created are known as entering elements and ones that are about to be removed are known as exiting elements.)\n\nIn some instances it’s useful to treat entering and exiting elements differently. This is especially the case when dealing with transitions. For example, if you’d like new elements to fade in you need to set their initial opacity to zero. Likewise if you’d like them to fade out before being removed, you need to set up a transition on each exiting element so that their opacity gradually reduces to zero.\n\n\n  Version 4 and below of D3 required you use a selection’s .enter and .exit methods. However from version 5 the .join method hides the intricacies of enter and exit from you. If you’re still working with version 4 you can still view the original chapter on enter and exit.\n\n\nYou can treat entering and exiting elements differently by passing functions into the .join method:\n\n.join(\n  function(enter) {\n    ...\n  },\n  function(update) {\n    ...\n  },\n  function(exit) {\n    ...\n  }\n)\n\nThe first, second and third functions are named the enter, update and exit functions, respectively.\n\nEach function has a single parameter::\n\n\n  the enter function’s parameter enter is the enter selection which represents the elements that need to be created\n  the update function’s parameter update is a selection containing the elements that are already in existence (and aren’t exiting)\n  the exit function’s parameter exit is the exit selection and contains elements that need to to be removed\n\n\nThe .join method returns a selection containing the entering and existing elements (it doesn’t contain exiting elements). Typically most of your style and attribute updates will follow the .join method.\n\nNote that the enter, update and exit functions must return the selection.\n\nEnter function\n\nIn general the enter function must append an element to each element of the enter selection. (The enter selection consists of ‘placeholder’ elements that represent the elements that need to be added.)\n\nFor example:\n\n.join(\n  function(enter) {\n    return enter.append('circle');\n  }\n)\n\nThis is equivalent to .join('circle').\n\nYou can also call the usual selection methods such as .style and .attr on the enter selection. This allows you to modify style and attributes of the entering elements.\n\nFor example:\n\n.join(\n  function(enter) {\n    return enter\n      .append('circle')\n      .style('opacity', 0);\n  }\n)\n\nUpdate function\n\nThe update function is optional and lets you update elements that are already in existence. For example:\n\n.join(\n  function(enter) {\n    return enter\n      .append('circle')\n      .style('opacity', 0);\n  },\n  function(update) {\n    return update.style('opacity', 1);\n  }\n)\n\nThis will set the opacity of entering circles to zero and the opacity of existing circles to 1.\n\nExit function\nThe exit function is optional and handles HTML/SVG elements that need to be removed. In general you need to remove the elements in the exit selection:\n\n.join(\n  function(enter) {\n    return enter\n      .append('circle')\n      .style('opacity', 0);\n  },\n  function(update) {\n    return update\n      .style('opacity', 1);\n  },\n  function(exit) {\n    return exit.remove();\n  }\n)\n\nExample\n\nIf you’re not using transitions you rarely need to the above techniques. However if you are using transitions and you want to control how elements enter and exit the page, you will need the above techniques. See the transitions chapter for examples using transitions.\n\nFor now, to help your understanding, here’s an example that sets the opacity of entering nodes to 0.25:\n\nfunction getData() {\n  let data = [];\n  let numItems = Math.ceil(Math.random() * 5);\n\n  for(let i=0; i<numItems; i++) {\n    data.push(40);\n  }\n\n  return data;\n}\n\nfunction update(data) {\n  d3.select('.chart')\n    .selectAll('circle')\n    .data(data)\n    .join(\n      function(enter) {\n        return enter.append('circle')\n          .style('opacity', 0.25);\n      },\n      function(update) {\n        return update.style('opacity', 1);\n      }\n    )\n    .attr('cx', function(d, i) {\n      return i * 100;\n    })\n    .attr('cy', 50)\n    .attr('r', function(d) {\n      return 0.5 * d;\n    })\n    .style('fill', 'orange');\n}\n\nfunction updateAll() {\n\tlet myData = getData();\n\tupdate(myData);\n}\n\nupdateAll();\n\nd3.select(\"button\")\n\t.on(\"click\", updateAll);\n\n\n\n\n\n\n  \n\n\nThe enter function appends a circle to each element in the enter selection and sets their opacity to 0.25. The update function sets the opacity of existing circles to 1. The .attr and .style methods after the .join method apply to entering and existing elements.\n\nNow circles that have just entered the page are feint, while those that were already in existence are solid.\n\nThe above example is not very representative of how you’d use enter, exit and update functions in practice. See the transitions for more representative examples.\n\n\n  ",
	"\n  \tHow to use D3 scale functions to transform data values into visual values such as positions and colours. After explaning scale basics we cover linear, square root, log, sequential, quantized, quantile, threshold, ordinal, band and point scales.\n\nScale functions are JavaScript functions that:\n\n\n  take an input (usually a number, date or category) and\n  return a value (such as a coordinate, a colour, a length or a radius)\n\n\nThey’re typically used to transform (or ‘map’) data values into visual variables (such as position, length and colour).\n\nFor example, suppose you have some data:\n\n[ 0, 2, 3, 5, 7.5, 9, 10 ]\n\nyou can create a scale function using:\n\nlet myScale = d3.scaleLinear()\n  .domain([0, 10])\n  .range([0, 600]);\n\nD3 creates a function myScale which accepts input between 0 and 10 (the domain) and maps it to output between 0 and 600 (the range).\n\nYou can use myScale to calculate positions based on the data:\n\nmyScale(0);   // returns 0\nmyScale(2);   // returns 120\nmyScale(3);   // returns 180\n...\nmyScale(10);  // returns 600\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nScales are mainly used for transforming data values to visual variables such as position, length and colour.\n\nFor example they can transform:\n\n\n  data values into lengths between 0 and 500 for a bar chart\n  data values into positions between 0 and 200 for line charts\n  % change data (+4%, +10%, -5% etc.) into a continuous range of colours (with red for negative and green for positive)\n  dates into positions along an x-axis.\n\n\nConstructing scales\n\n(In this chapter we’ll just focus on linear scales as these are the most commonly used scale type. We’ll cover other types later on.)\n\nTo create a linear scale you use:\n\nlet myScale = d3.scaleLinear();\n\nVersions 4 and above use a different naming convention to v3. `d3.scaleLinear()` is used in v4 and above and `d3.scale.linear()` is used in v3.\n\nAs it stands the above function isn’t very useful so you can configure the input bounds (the domain) as well as the output bounds (the range):\n\nmyScale\n  .domain([0, 100])\n  .range([0, 800]);\n\nThis results in a scale function that accepts input between 0 and 100 and linearly maps it to between 0 and 800:\n\nmyScale(0);    // returns 0\nmyScale(50);   // returns 400\nmyScale(100);  // returns 800\n\nTry experimenting with scale functions by copying code fragments and pasting them into the console of this page. (I've included D3 version 6.2.0 on every page of D3 in Depth.)\n\nD3 scale types\n\nD3 has around 12 different scale types (scaleLinear, scalePow, scaleQuantise, scaleOrdinal etc.) and broadly speaking they can be classified into 3 groups:\n\n\n  scales with continuous input and continuous output\n  scales with continuous input and discrete output\n  scales with discrete input and discrete output\n\n\n\n  Continuous data is typically numeric data but also includes time and dates. Discrete data has a set number of values (such as the twelve months of the year).)\n\n\nWe’ll now look at each of these three categories.\n\nScales with continuous input and continuous output\n\nIn this chapter we cover scale functions that map from a continuous input domain to a continuous output range.\n\nscaleLinear\n\nLinear scales are probably the most commonly used scale type as they are the most suitable scale for transforming data values into positions and lengths.\n\nThey use a linear function y=mx+c to interpolate across the domain and range. (Imagine a graph where the domain is on the x-axis and the range is on the y-axis.)\n\nlet linearScale = d3.scaleLinear()\n  .domain([0, 10])\n  .range([0, 600]);\n\nlinearScale(0);   // returns 0\nlinearScale(5);   // returns 300\nlinearScale(10);  // returns 600\n\nLinear scale functions are typically used to transform data values into positions and lengths. They are useful when creating bar charts, line charts and many other chart types.\n\nThe output range can also be specified as colours:\n\nlet linearScale = d3.scaleLinear()\n  .domain([0, 10])\n  .range(['yellow', 'red']);\n\nlinearScale(0);   // returns \"rgb(255, 255, 0)\"\nlinearScale(5);   // returns \"rgb(255, 128, 0)\"\nlinearScale(10);  // returns \"rgb(255, 0, 0)\"\n\nThis can be useful for visualisations such as choropleth maps, but also consider scaleQuantize, scaleQuantile and scaleThreshold.\n\nscaleSqrt\n\nThe scaleSqrt scale is useful for sizing circles by area (rather than radius). (When using circle size to represent data, it’s considered better practice to set the area, rather than the radius proportionally to the data.)\n\nlet sqrtScale = d3.scaleSqrt()\n  .domain([0, 100])\n  .range([0, 30]);\n\nsqrtScale(0);   // returns 0\nsqrtScale(50);  // returns 21.21...\nsqrtScale(100); // returns 30\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nscalePow\n\nscalePow is a more general version of scaleSqrt. This scale interpolates using a power function y=mxk+c. The exponent k is set using .exponent():\n\nlet powerScale = d3.scalePow()\n  .exponent(0.5)\n  .domain([0, 100])\n  .range([0, 30]);\n\npowerScale(0);   // returns 0\npowerScale(50);  // returns 21.21...\npowerScale(100); // returns 30\n\n(I’ve never used this scale, by the way!)\n\nscaleLog\n\nscaleLog interpolates using a log function y=m*log(x)+b and can be useful when the data has an exponential nature to it.\n\nlet logScale = d3.scaleLog()\n  .domain([10, 100000])\n  .range([0, 600]);\n\nlogScale(10);     // returns 0\nlogScale(100);    // returns 150\nlogScale(1000);   // returns 300\nlogScale(100000); // returns 600\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nscaleTime\n\nscaleTime is similar to scaleLinear except the domain is expressed as an array of dates. (It’s very useful when dealing with time series data.)\n\ntimeScale = d3.scaleTime()\n  .domain([new Date(2016, 0, 1), new Date(2017, 0, 1)])\n  .range([0, 700]);\n\ntimeScale(new Date(2016, 0, 1));   // returns 0\ntimeScale(new Date(2016, 6, 1));   // returns 348.00...\ntimeScale(new Date(2017, 0, 1));   // returns 700\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nscaleSequential\n\nscaleSequential is used for mapping continuous values to an output range determined by a preset (or custom) interpolator. (An interpolator is a function that accepts input between 0 and 1 and outputs an interpolated value between two numbers, colours, strings etc.)\n\nD3 provides a number of preset interpolators including many colour ones. For example you can use d3.interpolateRainbow to create the well known rainbow colour scale:\n\nlet sequentialScale = d3.scaleSequential()\n  .domain([0, 100])\n  .interpolator(d3.interpolateRainbow);\n\nsequentialScale(0);   // returns 'rgb(110, 64, 170)'\nsequentialScale(50);  // returns 'rgb(175, 240, 91)'\nsequentialScale(100); // returns 'rgb(110, 64, 170)'\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nNote that the interpolator determines the output range so you don’t need to specify the range yourself.\n\nThe example below shows some of the other colour interpolators provided by D3:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nThere’s also a plug-in d3-scale-chromatic which provides the well known ColorBrewer colour schemes.\n\nClamping\n\nBy default scaleLinear, scalePow, scaleSqrt, scaleLog, scaleTime and scaleSequential extrapolate when the input value goes beyond the domain.\n\nFor example:\n\nlet linearScale = d3.scaleLinear()\n  .domain([0, 10])\n  .range([0, 100]);\n\nlinearScale(20);  // returns 200\nlinearScale(-10); // returns -100\n\nYou can clamp the scale function so that the input value stays within the domain using .clamp:\n\nlinearScale.clamp(true);\n\nlinearScale(20);  // returns 100\nlinearScale(-10); // returns 0\n\nYou can switch off clamping using .clamp(false).\n\nNice\n\nIf the domain has been computed automatically from real data (e.g. by using d3.extent) the start and end values might not be round figures. This isn’t necessarily a problem, but if using the scale to define an axis, it can look a bit untidy:\n\nlet data = [0.243, 0.584, 0.987, 0.153, 0.433];\nlet extent = d3.extent(data);\n\nlet linearScale = d3.scaleLinear()\n  .domain(extent)\n  .range([0, 100]);\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nTherefore D3 provides a function .nice() on the scales in this chapter which will round the domain to ‘nice’ round values:\n\nlet data = [0.243, 0.584, 0.987, 0.153, 0.433];\nlet extent = d3.extent(data);\n\nlet linearScale = d3.scaleLinear()\n  .domain(extent)\n  .range([0, 100])\n  .nice();\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nNote that .nice() must be called each time the domain is updated.\n\nMultiple segments\n\nThe domain and range of scaleLinear, scalePow, scaleSqrt, scaleLog and scaleTime usually consists of two values, but if you provide 3 or more values the scale function is subdivided into multiple segments:\n\nlet linearScale = d3.scaleLinear()\n  .domain([-10, 0, 10])\n  .range(['red', '#ddd', 'blue']);\n\nlinearScale(-10);  // returns \"rgb(255, 0, 0)\"\nlinearScale(0);    // returns \"rgb(221, 221, 221)\"\nlinearScale(5);    // returns \"rgb(111, 111, 238)\"\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nTypically multiple segments are used for distinguishing between negative and positive values (such as in the example above). You can use as many segments as you like as long as the domain and range are of the same length.\n\nInversion\n\nThe .invert() method lets you determine a scale function’s input value given an output value (provided the scale function has a numeric domain):\n\nlet linearScale = d3.scaleLinear()\n  .domain([0, 10])\n  .range([0, 100]);\n\nlinearScale.invert(50);   // returns 5\nlinearScale.invert(100);  // returns 10\n\nA common use case is when you want to convert a user’s click along an axis into a domain value:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nScales with continuous input and discrete output\n\nscaleQuantize\n\nscaleQuantize accepts continuous input and outputs a number of discrete quantities defined by the range.\n\nlet quantizeScale = d3.scaleQuantize()\n  .domain([0, 100])\n  .range(['lightblue', 'orange', 'lightgreen', 'pink']);\n\nquantizeScale(10);  // returns 'lightblue'\nquantizeScale(30);  // returns 'orange'\nquantizeScale(90);  // returns 'pink'\n\nEach range value is mapped to an equal sized chunk in the domain so in the example above:\n\n\n  0 ≤ u < 25 is mapped to ‘lightblue’\n  25 ≤ u < 50 is mapped to ‘orange’\n  50 ≤ u < 75 is mapped to ‘lightgreen’\n  75 ≤ u < 100 is mapped to ‘pink’\n\n\nwhere u is the input value.\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nInput values outside the domain are clamped so in our example quantizeScale(-10) returns ‘lightblue’ and quantizeScale(110) returns ‘pink’.\n\nscaleQuantile\n\nscaleQuantile maps continuous numeric input to discrete values. The domain is defined by an array of numbers:\n\nlet myData = [0, 5, 7, 10, 20, 30, 35, 40, 60, 62, 65, 70, 80, 90, 100];\n\nlet quantileScale = d3.scaleQuantile()\n  .domain(myData)\n  .range(['lightblue', 'orange', 'lightgreen']);\n\nquantileScale(0);   // returns 'lightblue'\nquantileScale(20);  // returns 'lightblue'\nquantileScale(30);  // returns 'orange'\nquantileScale(65);  // returns 'lightgreen'\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nThe (sorted) domain array is divided into n equal sized groups where n is the number of range values.\n\nTherefore in the above example the domain array is split into 3 groups where:\n\n\n  the first 5 values are mapped to ‘lightblue’\n  the next 5 values to ‘orange’ and\n  the last 5 values to ‘lightgreen’.\n\n\nThe split points of the domain can be accessed using .quantiles():\n\nquantileScale.quantiles();  // returns [26.66..., 63]\n\nIf the range contains 4 values quantileScale computes the quartiles of the data. In other words, the lowest 25% of the data is mapped to range[0], the next 25% of the data is mapped to range[1] etc.\n\nscaleThreshold\n\nscaleThreshold maps continuous numeric input to discrete values defined by the range. n-1 domain split points are specified where n is the number of range values.\n\nIn the following example we split the domain at 0, 50 and 100\n\n\n  u < 0 is mapped to ‘#ccc’\n  0 ≤ u < 50 to ‘lightblue’\n  50 ≤ u < 100 to ‘orange’\n  u ≥ 100 to ‘#ccc’\n\n\nwhere u is the input value.\n\nlet thresholdScale = d3.scaleThreshold()\n  .domain([0, 50, 100])\n  .range(['#ccc', 'lightblue', 'orange', '#ccc']);\n\nthresholdScale(-10);  // returns '#ccc'\nthresholdScale(20);   // returns 'lightblue'\nthresholdScale(70);   // returns 'orange'\nthresholdScale(110);  // returns '#ccc'\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nScales with discrete input and discrete output\n\nscaleOrdinal\n\nscaleOrdinal maps discrete values (specified by an array) to discrete values (also specified by an array). The domain array specifies the possible input values and the range array the output values. The range array will repeat if it’s shorter than the domain array.\n\nlet myData = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\nlet ordinalScale = d3.scaleOrdinal()\n  .domain(myData)\n  .range(['black', '#ccc', '#ccc']);\n\nordinalScale('Jan');  // returns 'black';\nordinalScale('Feb');  // returns '#ccc';\nordinalScale('Mar');  // returns '#ccc';\nordinalScale('Apr');  // returns 'black';\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nBy default if a value that’s not in the domain is used as input, the scale will implicitly add the value to the domain:\n\nordinalScale('Monday');  // returns 'black';\n\nIf this isn’t the desired behvaiour you can specify an output value for unknown values using .unknown():\n\nordinalScale.unknown('Not a month');\nordinalScale('Tuesday'); // returns 'Not a month'\n\nD3 can also provide preset colour schemes (from ColorBrewer):\n\nlet ordinalScale = d3.scaleOrdinal()\n  .domain(myData)\n  .range(d3.schemePaired);\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nscaleBand\n\nWhen creating bar charts scaleBand helps to determine the geometry of the bars, taking into account padding between each bar. The domain is specified as an array of values (one value for each band) and the range as the minimum and maximum extents of the bands (e.g. the total width of the bar chart).\n\nIn effect scaleBand will split the range into n bands (where n is the number of values in the domain array) and compute the positions and widths of the bands taking into account any specified padding.\n\nlet bandScale = d3.scaleBand()\n  .domain(['Mon', 'Tue', 'Wed', 'Thu', 'Fri'])\n  .range([0, 200]);\n\nbandScale('Mon'); // returns 0\nbandScale('Tue'); // returns 40\nbandScale('Fri'); // returns 160\n\nThe width of each band can be accessed using .bandwidth():\n\nbandScale.bandwidth();  // returns 40\n\nTwo types of padding may be configured:\n\n\n  paddingInner which specifies (as a percentage of the band width) the amount of padding between each band\n  paddingOuter which specifies (as a percentage of the band width) the amount of padding before the first band and after the last band\n\n\nLet’s add some inner padding to the example above:\n\nbandScale.paddingInner(0.05);\n\nbandScale.bandWidth();  // returns 38.38...\nbandScale('Mon');       // returns 0\nbandScale('Tue');       // returns 40.40...\n\nPutting this all together we can create this bar chart:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nscalePoint\n\nscalePoint creates scale functions that map from a discrete set of values to equally spaced points along the specified range:\n\nlet pointScale = d3.scalePoint()\n  .domain(['Mon', 'Tue', 'Wed', 'Thu', 'Fri'])\n  .range([0, 500]);\n\npointScale('Mon');  // returns 0\npointScale('Tue');  // returns 125\npointScale('Fri');  // returns 500\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nThe distance between the points can be accessed using .step():\n\npointScale.step();  // returns 125\n\nOutside padding can be specified as the ratio of the padding to point spacing. For example, for the outside padding to be a quarter of the point spacing use a value of 0.25:\n\npointScale.padding(0.25);\n\npointScale('Mon');  // returns 27.77...\npointScale.step();  // returns 111.11...\n\nFurther reading\n\nColorBrewer schemes for D3\n\nMike Bostock on d3-scale\n\n\n  ",
	"\n  \tHow to create commonly used chart shapes such as multi-segment lines, areas, stacked bars, stacked areas, streamgraphs, pie segments and symbols using D3. Also covers rendering to canvas.\n\nThis chapter looks at the functions D3 provides for taking the effort out of drawing shapes such as lines:\n\n\n\n\n\n\n  \n\n\ncurves:\n\n\n\n\n\n\n  \n\n\npie chart segments:\n\n\n\n\n\n\n  \n\n\nand symbols:\n\n\n\n\n\n\n  \n\n\nSVG\n\nThe shapes in the above examples are made up of SVG path elements. Each of them has a d attribute (path data) which defines the shape of the path.\n\nThe path data consists of a list of commands such as M0,80L100,100L200,30L300,50L400,40L500,80 which describe the shape of the path. Each letter such as M or L describe a command such as ‘move to’ and ‘draw a line to’. See the SVG specification for more detail.\n\nYou can create path data yourself but D3 provides generator functions that do the work for you. These come in various forms:\n\n\n  lineGenerates path data for a multi-segment line (typically for line charts)\n  areaGenerates path data for an area (typically for stacked line charts and streamgraphs)\n  stackGenerates stack data from multi-series data\n  arcGenerates path data for an arc (typically for pie charts)\n  pieGenerates pie angle data from array of data\n  symbolGenerates path data for symbols such as plus, star, diamond\n\n\nThere’s also a generator for creating path data from GeoJSON. This is covered in the geographic section.\n\nLine generator\n\nD3’s line generator produces a path data string given an array of co-ordinates.\n\nYou create a line generator using d3.line():\n\nvar lineGenerator = d3.line();\n\nd3.line() returns a function that accepts an array of co-ordinates and outputs a path data string.\n\nLet’s define an array of co-ordinates:\n\nvar points = [\n  [0, 80],\n  [100, 100],\n  [200, 30],\n  [300, 50],\n  [400, 40],\n  [500, 80]\n];\n\nand call lineGenerator with the array as the argument:\n\nvar pathData = lineGenerator(points); // returns \"M0,80L100,100L200,30L300,50L400,40L500,80\"\n\nlineGenerator creates a string of M (move to) and L (line to) commands from the array of points.\n\nYou can use pathData to set the d attribute of a path element:\n\nd3.select('path')\n  .attr('d', pathData);\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n.x and .y methods\n\nBy default each array element represents a co-ordinate defined by a 2-dimensional array (e.g. [0, 100]). However you can specify how the line generator interprets each array element using the methods .x and .y.\n\nFor example suppose your data is an array of objects:\n\nvar data = [\n  {value: 10},\n  {value: 50},\n  {value: 30},\n  {value: 40},\n  {value: 20},\n  {value: 70},\n  {value: 50}\n];\n\nIf you pass functions into the .x and .y methods of lineGenerator D3 will apply these functions to each array element:\n\nvar xScale = d3.scaleLinear().domain([0, 6]).range([0, 600]);\nvar yScale = d3.scaleLinear().domain([0, 80]).range([150, 0]);\n\nlineGenerator\n  .x(function(d, i) {\n    return xScale(i);\n  })\n  .y(function(d) {\n    return yScale(d.value);\n  });\n\nThe x coordinate is set using a linear scale function applied to the array index. This results in equidistant points in the x direction. The y coodinate is set using a linear scale applied to the value property:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n\n  The functions passed into the .x and .y methods (and other similar methods) are known as accessor functions.\n\n\n.defined()\n\nYou can configure the behaviour when there’s missing data. Suppose your data has a gap in it:\n\nvar points = [\n  [0, 80],\n  [100, 100],\n  null,\n  [300, 50],\n  [400, 40],\n  [500, 80]\n];\n\nthe line generator will raise an error.\n\nTo overcome this you can use the .defined method. You pass in a function that returns true if the data is well defined. If the function returns false the line generator will skip over it:\n\nlineGenerator\n  .defined(function(d) {\n    return d !== null;\n  });\n\nNow when you call lineGenerator it leaves a gap in the line:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n.curve()\n\nYou can configure how the points are interpolated. For example you can interpolate each data point with a B-spline:\n\nvar lineGenerator = d3.line()\n  .curve(d3.curveCardinal);\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nAlthough there’s a multitude of different curve types available they can be divided into two camps: those which pass through the points (curveLinear, curveCardinal, curveCatmullRom, curveMonotone, curveNatural and curveStep) and those that don’t (curveBasis and curveBundle).\n\nSee the curve explorer for more information.\n\nRendering to canvas\n\nBy default the shape generators output SVG path data. However they can be configured to draw to a canvas element using the .context() function:\n\nvar context = d3.select('canvas').node().getContext('2d');\n\nlineGenerator.context(context);\n\ncontext.strokeStyle = '#999';\ncontext.beginPath();\nlineGenerator(points);\ncontext.stroke();\n\n\n\n\t\n\t\n\t\n\n\n\nRadial line\n\nThe radial line generator is similar to the line generator but the points are transformed by angle (working clockwise from 12 o’clock) and radius, rather than x and y:\n\nvar radialLineGenerator = d3.radialLine();\n\nvar points = [\n  [0, 80],\n  [Math.PI * 0.25, 80],\n  [Math.PI * 0.5, 30],\n  [Math.PI * 0.75, 80],\n  [Math.PI, 80],\n  [Math.PI * 1.25, 80],\n  [Math.PI * 1.5, 80],\n  [Math.PI * 1.75, 80],\n  [Math.PI * 2, 80]\n];\n\nvar pathData = radialLineGenerator(points);\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nThe radialLine generator also has methods .angle and .radius into which you can pass accessor functions. These are handy if you’ve an array of objects:\n\nvar points = [\n  {a: 0, r: 80},\n  {a: Math.PI * 0.25, r: 80},\n  {a: Math.PI * 0.5, r: 30},\n  {a: Math.PI * 0.75, r: 80},\n  ...\n];\n\nradialLineGenerator\n  .angle(function(d) {\n    return d.a;\n  })\n  .radius(function(d) {\n    return d.r;\n  });\n\nvar pathData = radialLineGenerator(points);\n\nArea generator\n\nThe area generator outputs path data that defines an area between two lines. By default it generates the area between y=0 and a multi-segment line defined by an array of points:\n\nvar areaGenerator = d3.area();\n\nvar points = [\n  [0, 80],\n  [100, 100],\n  [200, 30],\n  [300, 50],\n  [400, 40],\n  [500, 80]\n];\n\nvar pathData = areaGenerator(points);\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nYou can configure the baseline using the .y0 method:\n\nareaGenerator.y0(150);\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nYou can also pass accessor functions into the .y0 and .y1 methods:\n\nvar yScale = d3.scaleLinear().domain([0, 100]).range([200, 0]);\n\nvar points = [\n  {x: 0, low: 30, high: 80},\n  {x: 100, low: 80, high: 100},\n  {x: 200, low: 20, high: 30},\n  {x: 300, low: 20, high: 50},\n  {x: 400, low: 10, high: 40},\n  {x: 500, low: 50, high: 80}\n];\n\nareaGenerator\n  .x(function(d) {\n    return d.x;\n  })\n  .y0(function(d) {\n    return yScale(d.low);\n  })\n  .y1(function(d) {\n    return yScale(d.high);\n  });\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n\n  Typically .y0 defines the baseline and .y1 the top line.\n\n\nAs with the line generator you can specify the way in which the points are interpolated using .curve(), handle missing data using .defined() and render to canvas using .context().\n\nRadial area\n\nThe radial area generator is similar to the area generator but the points are transformed by angle (working clockwise from 12 o’clock) and radius, rather than x and y:\n\nvar points = [\n  {angle: 0, r0: 30, r1: 80},\n  {angle: Math.PI * 0.25, r0: 30, r1: 70},\n  {angle: Math.PI * 0.5, r0: 30, r1: 80},\n  {angle: Math.PI * 0.75, r0: 30, r1: 70},\n  {angle: Math.PI, r0: 30, r1: 80},\n  {angle: Math.PI * 1.25, r0: 30, r1: 70},\n  {angle: Math.PI * 1.5, r0: 30, r1: 80},\n  {angle: Math.PI * 1.75, r0: 30, r1: 70},\n  {angle: Math.PI * 2, r0: 30, r1: 80}\n];\n\nvar radialAreaGenerator = d3.radialArea()\n  .angle(function(d) {\n    return d.angle;\n  })\n  .innerRadius(function(d) {\n    return d.r0;\n  })\n  .outerRadius(function(d) {\n    return d.r1;\n  });\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nStack generator\n\nThe stack generator takes an array of objects and generates an array for each object property. Each array contains lower and upper values for each data point. The lower and upper values are computed so that each series is stacked on top of the previous series.\n\nIn this example we’ve an array of objects. We create a stack generator using d3.stack. We use its .keys method to pass in the property keys which we’d like to stack. In this case we’re stacking apricots, blueberries and cherries:\n\nvar data = [\n  {day: 'Mon', apricots: 120, blueberries: 180, cherries: 100},\n  {day: 'Tue', apricots: 60,  blueberries: 185, cherries: 105},\n  {day: 'Wed', apricots: 100, blueberries: 215, cherries: 110},\n  {day: 'Thu', apricots: 80,  blueberries: 230, cherries: 105},\n  {day: 'Fri', apricots: 120, blueberries: 240, cherries: 105}\n];\n\nvar stack = d3.stack()\n  .keys(['apricots', 'blueberries', 'cherries']);\n\nvar stackedSeries = stack(data);\n\n// stackedSeries = [\n//   [ [0, 120],   [0, 60],   [0, 100],    [0, 80],    [0, 120] ],   // Apricots\n//   [ [120, 300], [60, 245], [100, 315],  [80, 310],  [120, 360] ], // Blueberries\n//   [ [300, 400], [245, 350], [315, 425], [310, 415], [360, 465] ]  // Cherries\n// ]\n\nThe data output by the stack generator can be used however you like, but typically it’ll be used to produce stacked bar charts:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nor when used in conjunction with the area generator, stacked line charts:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n.order()\n\nThe order of the stacked series can be configured using .order():\n\nstack.order(d3.stackOrderInsideOut);\n\nEach series is summed and then sorted according to the chosen order. The possible orders are:\n\n\n  stackOrderNone(Default) Series in same order as specified in .keys()\n  stackOrderAscendingSmallest series at the bottom\n  stackOrderDescendingLargest series at the bottom\n  stackOrderInsideOutLargest series in the middle\n  stackOrderReverseReverse of stackOrderNone\n\n\n.offset()\n\nBy default the stacked series have a baseline of zero. However you can configure the offset of the stack generator to achieve different effects. For example you can normalise the stacked series so that they fill the same height:\n\nstack.offset(d3.stackOffsetExpand);\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nThe available offsets are:\n\n\n  stackOffsetNone(Default) No offset\n  stackOffsetExpandSum of series is normalised (to a value of 1)\n  stackOffsetSilhouetteCenter of stacks is at y=0\n  stackOffsetWiggleWiggle of layers is minimised (typically used for streamgraphs)\n\n\nHere’s a streamgraph example using stackOffsetWiggle:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nArc generator\n\nArc generators produce path data from angle and radius values. An arc generator is created using:\n\nvar arcGenerator = d3.arc();\n\nIt can then be passed an object containing startAngle, endAngle, innerRadius and outerRadius properties to produce the path data:\n\nvar pathData = arcGenerator({\n  startAngle: 0,\n  endAngle: 0.25 * Math.PI,\n  innerRadius: 50,\n  outerRadius: 100\n});\n\n// pathData is \"M6.123233995736766e-15,-100A100,100,0,0,1,70.71067811865476,-70.710678\n// 11865474L35.35533905932738,-35.35533905932737A50,50,0,0,0,3.061616997868383e-15,-50Z\"\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n\n  startAngle and endAngle are measured clockwise from the 12 o’clock in radians.\n\n\nConfiguration\n\nYou can configure innerRadius, outerRadius, startAngle, endAngle so that you don’t have to pass them in each time:\n\narcGenerator\n  .innerRadius(20)\n  .outerRadius(100);\n\npathData = arcGenerator({\n  startAngle: 0,\n  endAngle: 0.25 * Math.PI\n});\n\n// pathData is \"M6.123233995736766e-15,-100A100,100,0,0,1,70.71067811865476,-70.71067811\n// 865474L14.142135623730951,-14.14213562373095A20,20,0,0,0,1.2246467991473533e-15,-20Z\"\n\n\n\n\t\n\t\n\t\n\n\n\nYou can also configure corner radius (cornerRadius) and the padding between arc segments (padAngle and padRadius):\n\narcGenerator\n  .padAngle(.02)\n  .padRadius(100)\n  .cornerRadius(4);\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nArc padding takes two parameters padAngle and padRadius which when multiplied together define the distance between adjacent segments. Thus in the example above, the padding distance is 0.02 * 100 = 2. Note that the padding is calculated to maintain (where possible) parallel segment boundaries.\n\nYou might ask why there isn't a single parameter padDistance for defining the padding distance. It's split into two parameters so that the pie generator (see later) doesn't need to concern itself with radius.\n\nAccessor functions\n\nYou can define accessor functions for startAngle, endAngle, innerRadius and outerRadius. For example:\n\narcGenerator\n  .startAngle(function(d) {\n    return d.startAngleOfMyArc;\n  })\n  .endAngle(function(d) {\n    return d.endAngleOfMyArc;\n  });\n\narcGenerator({\n  startAngleOfMyArc: 0,\n  endAngleOfMyArc: 0.25 * Math.PI\n});\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nCentroid\n\nIt’s sometimes useful to calculate the centroid of an arc, such as when positioning labels, and D3 has a function .centroid() for doing this:\n\narcGenerator.centroid({\n  startAngle: 0,\n  endAngle: 0.25 * Math.PI\n});\n// returns [22.96100594190539, -55.43277195067721]\n\nHere’s an example where .centroid() is used to compute the label positions:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nPie generator\n\nThe pie generator goes hand in hand with the arc generator. Given an array of data, the pie generator will output an array of objects containing the original data augmented by start and end angles:\n\nvar pieGenerator = d3.pie();\nvar data = [10, 40, 30, 20, 60, 80];\nvar arcData = pieGenerator(data);\n\n// arcData is an array of objects: [\n//   {\n//     data: 10,\n//     endAngle: 6.28...,\n//     index: 5,\n//     padAngle: 0,\n//     startAngle: 6.02...,\n//     value: 10\n//   },\n//   ...\n// ]\n\nYou can then use an arc generator to create the path strings:\n\nvar arcGenerator = d3.arc()\n  .innerRadius(20)\n  .outerRadius(100);\n\nd3.select('g')\n  .selectAll('path')\n  .data(arcData)\n  .enter()\n  .append('path')\n  .attr('d', arcGenerator);\n\nNotice that the output of pieGenerator contains the properties startAngle and endAngle. These are the same properties required by arcGenerator.\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nThe pie generator has a number of configuration functions including .padAngle(), .startAngle(), .endAngle() and .sort(). .padAngle() specifies an angular padding (in radians) between neighbouring segments.\n\n.startAngle() and .endAngle() configure the start and end angle of the pie chart. This allows, for example, the creation of semi-circular pie charts:\n\nvar pieGenerator = d3.pie()\n  .startAngle(-0.5 * Math.PI)\n  .endAngle(0.5 * Math.PI);\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nBy default the segment start and end angles are specified such that the segments are in descending order. However we can change the sort order using .sort:\n\nvar pieGenerator = d3.pie()\n  .value(function(d) {return d.quantity;})\n  .sort(function(a, b) {\n    return a.name.localeCompare(b.name);\n  });\n\nvar fruits = [\n  {name: 'Apples', quantity: 20},\n  {name: 'Bananas', quantity: 40},\n  {name: 'Cherries', quantity: 50},\n  {name: 'Damsons', quantity: 10},\n  {name: 'Elderberries', quantity: 30},\n];\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nSymbols\n\nThe symbol generator produces path data for symbols commonly used in data visualisation:\n\nvar symbolGenerator = d3.symbol()\n  .type(d3.symbolStar)\n  .size(80);\n\nvar pathData = symbolGenerator();\n\nYou can use pathData to define the d attribute of a path element:\n\nd3.select('path')\n  .attr('d', pathData);\n\nHere’s a simple chart using the symbol generator:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nD3 provides a number of symbol types:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n\n  ",
	"\n  \tHow to create chart axes using D3’s axis module. This article covers axis orientation, transitions, number of ticks, custom tick values, tick formatting and tick size.\n\nOne of the most useful D3 modules (especially when creating bar, line and scatter charts) is the axis module which draws axes:\n\n\n\n\n\n\n  \n\n\nHow to create an axis\n\nYou need two things to create a D3 axis:\n\n\n  an SVG element to contain the axis (usually a g element)\n  a D3 scale function\n\n\nA D3 scale function has a domain and range (see the scales chapter). The domain specifies the input extent (for example [0, 100]) and the range defines the output extent (for example [0, 1000]) of the scale.\n\nWhen a D3 scale function is used to define an axis, the scale domain determines the minimum and maximum tick values and the range determines the length of the axis.\n\nTo create an axis:\n\n\n  make an axis generator function using d3.axisBottom, d3.axisTop, d3.axisLeft or d3.axisRight (and pass in your scale function)\n  select the container element and pass the axis generator into .call\n\n\nHere’s a basic example:\n\n<svg width=\"600\" height=\"100\">\n  <g transform=\"translate(20, 50)\"></g>\n</svg>\n\nlet scale = d3.scaleLinear().domain([0, 100]).range([0, 500]);\n\nlet axis = d3.axisBottom(scale);\n\nd3.select('svg g')\n  .call(axis);\n\n\n\n\n\n\n  \n\n\n\n  We cover .call in the selections chapter. In brief you pass a function into .call. The function’s first parameter is a selection with which the function can operate on. An axis generator (the axis variable in the above example) appends path, line and text elements (that represent the axis) to the selection.\n\n\n\n  The axis can be positioned by transforming the axis’s container. In the above example, the g element that contains the axis is translated by (20, 50).\n\n\nAxis orientation\n\nd3.axisBottom, d3.axisTop, d3.axisLeft and d3.axisRight are used to generate axes that are suitable for the bottom, top, left and right of a chart, respectively:\n\n<svg width=\"500\" height=\"500\">\n  <g id=\"left\" transform=\"translate(30, 40)\"></g>\n  <g id=\"right\" transform=\"translate(450, 40)\"></g>\n  <g id=\"top\" transform=\"translate(40, 30)\"></g>\n  <g id=\"bottom\" transform=\"translate(40, 450)\"></g>\n</svg>\n\nlet scale = d3.scaleLinear().domain([0, 100]).range([0, 400]);\n\nlet axisLeft = d3.axisLeft(scale);\nlet axisRight = d3.axisRight(scale);\nlet axisTop = d3.axisTop(scale);\nlet axisBottom = d3.axisBottom(scale);\n\nd3.select('#left').call(axisLeft);\nd3.select('#right').call(axisRight);\nd3.select('#top').call(axisTop);\nd3.select('#bottom').call(axisBottom);\n\n\n\n\n\n\n  \n\n\nScale types\n\nYou can pass in any scale function that has numeric output. This includes scaleLinear, scaleSqrt, scaleLog, scaleTime, scaleBand and scalePoint.\n\nHere’s an example using each scale type:\n\n\n\n\n\n\n  \n\n\n\n  scaleBand is useful for bar charts. Read more here.\n\n\nTransitions\n\nIf the scale’s domain changes, the axis can be updated by calling .call(axis) again:\n\nd3.select('svg g')\n  .call(axis);\n\nYou can also add a call to .transition to make the axis animate:\n\nd3.select('svg g')\n  .transition()\n  .call(axis);\n\n\n\n\n\n\n  \n\n\nAxis configuration\n\nYou can configure axes in the following ways:\n\n\n  specify the number of ticks OR specify the tick values\n  specify the format of the tick label (for example, add a percentage sign)\n  specify the tick size\n\n\nNumber of ticks\n\nYou can use the .ticks method to specify how many ticks the axis has:\n\nlet scale = d3.scaleLinear().domain([0, 100]).range([0, 500]);\n\nlet axis = d3.axisBottom(scale);\n\naxis.ticks(20);\n\nd3.select('svg g')\n  .call(axis);\n\n\n\n\n\n\n  \n\n\n\n  D3 tries to use as many ticks as requested, but in some cases it’ll use more or less in order for the tick values to be round numbers.\n\n\n\n  The axis uses its scale function’s .ticks method to generate an array of tick values.\n\n\nTick values\n\nYou can specify the axis’s tick values by passing an array of tick values into the .tickValues method:\n\nlet scale = d3.scaleLinear().domain([0, 100]).range([0, 500]);\n\nlet axis = d3.axisBottom(scale);\n\naxis.tickValues([0, 25, 50, 75, 100]);\n\nd3.select('svg g')\n  .call(axis);\n\n\n\n\n\n\n  \n\n\nTick label formatting\n\nYou can format the tick label in two ways.\n\nThe first is to use the .ticks method and pass in a format string as the second argument:\n\nlet scale = d3.scaleLinear().domain([0, 100]).range([0, 500]);\n\nlet axis = d3.axisBottom(scale);\n\naxis.ticks(4, \"$.2f\");\n\nd3.select('svg g')\n  .call(axis);\n\n\n\n\n\n\n  \n\n\n\n  We’ve already seen that the first argument of .ticks is the number of ticks. You can pass in null if you want to use the default number of ticks.\n\n\nThe format string is powerful and is described in depth in the d3-format section of the official documentation.\n\nThe second approach is to pass a formatting function into the .tickFormat method. The function accepts a value and outputs a formatted value.\n\nIn this example we add a % symbol to each tick value:\n\nlet scale = d3.scaleLinear().domain([0, 100]).range([0, 500]);\n\nlet axis = d3.axisBottom(scale);\n\naxis.ticks(4)\n  .tickFormat(function(d) {\n    return d + \"%\";\n  });\n\nd3.select('svg g')\n  .call(axis);\n\n\n\n\n\n\n  \n\n\nTick size\n\nThe length of the ticks can be set using the .tickSize method. You can also set the distance between the tick and the tick label using .tickPadding:\n\nlet scale = d3.scaleLinear().domain([0, 100]).range([0, 500]);\n\nlet axis = d3.axisBottom(scale)\n  .tickPadding(10)\n  .tickSize(10);\n\nd3.select('svg g')\n\t.call(axis);\n\n\n\n\n\n\n  \n\n\nThe axis is made up of a path element (that looks like a long square bracket and represents two end ticks and the main axis line) and line elements that represent each tick (including the end ticks).\n\nYou can set the length of the end ticks of the path element using .tickSizeOuter and the length of the line elements using .tickSizeInner. (I’m not sure of when this might be used.)\n\nYou can also create grid lines by setting the tick size to your chart width (or height). In this example we use axisLeft and set the tick size to 500. The axis also has a transform of translate(520, 20) and it’s path element that represents the main axis is hidden. (If the main axis was visible, you’d see it to the right of the grid lines.)\n\n\n\n\n\n\n  \n\n\n\n  ",
	"\n  \tHow to visualise hierarchical data (data in the shape of trees) using D3.js. This article shows how to create a nested (or hierarchical) data structure from an array of data. It also covers visualising hierarchies using D3, including treemaps, circle packing and sunburst charts.\n\nA common technique when analysing or visualising data is to organise your data into groups.\n\nFor example, here’s some film data:\n\n\nTitleDistributorGenreWorldwide_GrossRotten_Tomatoes_Rating\nAdaptationSony PicturesComedy2249852091\nAir BudWalt Disney PicturesComedy2755506145\nAir Force OneSony PicturesAction31526835378\nAlex & EmmaWarner Bros.Drama1535858311\nAlexanderWarner Bros.Adventure16729719116\nAliSony PicturesDrama8438396667\nAlice in WonderlandWalt Disney PicturesAdventure102329111051\nAliveWalt Disney PicturesAdventure3629967071\nAll the King's MenSony PicturesDrama952145811\nAmadeusWarner Bros.Drama5197302996\n\n\nLet’s group it according to Distributor and count the number of films in each group:\n\n\n  DistributorCount\n  Sony Pictures4\n  Walt Disney Pictures3\n  Warner Bros.3\n\n\nYou can also group by more than one category. For example let’s group by Distributor, then group by Genre:\n\n\n  DistributorGenreCount\n  \n    Sony PicturesAction1\n\tComedy1\n\tDrama2\n\tWalt Disney PicturesAdventure2\n\tComedy1\n\tWarner Bros.Adventure1\n\tDrama2\n  \n\n\n\n  In the world of spreadsheets, the above table is also known as a pivot table. If you’re familiar with databases you can achieve similar affects using the SQL statement GROUP BY.\n\n\nThe data how has a hierachical structure. At the top level are Distributors (Sony Pictures, Walt Disney Pictures etc.) and at the next level are Genres (Action, Adventure, Comedy etc.).\n\nYou can think of a hiearchical structure as a tree-like struture where a root item (or ‘node’) splits into top level groups (Distributors in our example). Each top level group splits into second level groups (Genres in our example), and so on:\n\n\n\n\n\n\n  \n\n\nThe topmost item (or node) is known as the root node. The bottommost items are known as leaves or leaf nodes. In the leaf nodes of the above example, the count is displayed under the dot.\n\nYou can also aggregate (or ‘rollup’) the groups in different ways. For example you can sum Worldwide_Gross:\n\n\n  DistributorGenreSum of Worldwide_Gross\n  \n    Sony PicturesAction315268353\n\tComedy22498520\n\tDrama93905424\n\tWalt Disney PicturesAdventure1059590780\n\tComedy27555061\n\tWarner Bros.Adventure167297191\n\tDrama67331612\n  \n\n\nThere are several ways in which hierarchical data can be visualised including trees, treemaps, packed circles and sunbursts. Each of these can be created using D3 and we’ll cover each of them later in this chapter.\n\nFirst we’ll look at how D3 can help us create a hierarchical data structure from flat data.\n\nCreating a hierarchy from an array of data\n\nGiven an array of data such as:\n\nlet data = [\n  {\n    \"Title\": \"Adaptation\",\n    \"Distributor\": \"Sony Pictures\",\n    \"Genre\": \"Comedy\",\n    \"Worldwide_Gross\": 22498520,\n    \"Rating\": 91\n  },\n  {\n    \"Title\": \"Air Bud\",\n    \"Distributor\": \"Walt Disney Pictures\",\n    \"Genre\": \"Comedy\",\n    \"Worldwide_Gross\": 27555061,\n    \"Rating\": 45\n  },\n  {\n    \"Title\": \"Air Force One\",\n    \"Distributor\": \"Sony Pictures\",\n    \"Genre\": \"Action\",\n    \"Worldwide_Gross\": 315268353,\n    \"Rating\": 78\n  },\n  ...\n];\n\nyou can use D3’s .rollup function to group the data by any of the categorical properties.\n\n\n  The above array is similar to the output of d3.csv. (See requests chapter.)\n\n\nThe first argument of .rollup is the array you’re wanting to group.\n\nThe next argument is a reduce function. This is a function that takes an array of values and outputs a single value. For example it might iterate through the array, summing one of the properties (such as Worldwide_Gross).\n\nThe remaining argument(s) are functions which specify which properties to group by.\n\nLet’s group by Distributor and Genre and sum Worldwide_Gross across the items in each group:\n\nfunction sumWorldwideGross(group) {\n  return d3.sum(group, function(d) {\n    return d.Worldwide_Gross;\n  });\n}\n\nlet groups = d3.rollup(data,\n                       sumWorldwideGross,\n                       function(d) { return d.Distributor; },\n                       function(d) { return d.Genre; }\n                      );\n\nIn the above example d3.rollup groups data by Distributor and Genre. Each of the groups is then passed into sumWorldwideGross which returns the sum of Worldwide_Gross.\n\nd3.rollup returns a nested map object. (Maps, just like regular JavaScript objects, hold key-value pairs. You can read more about them here.)\n\nYou can inspect the map returned by d3.rollup using .get:\n\n// Get Sony Pictures\ngroups.get('Sony Pictures');  // {\"Comedy\" => 22498520, \"Action\" => 315268353, \"Drama\" => 93905424}\n\n// Get Drama within Sony Pictures\ngroups.get('Sony Pictures').get('Drama');  // 93905424\n\n\n\n\n\n\n  \n\n\nThe first .get returns the group associated with Sony Pictures. This group contains 3 items: Comedy, Action and Drama. (You can compare this with the table we showed previously.)\n\nThe second .get returns the value associated with Drama within the Sony Pictures group (93905424). This returns the value computed by the rollup function (sumWorldwideGross) because we’re at the lowest level of the hieararchy.\n\nd3.hierarchy structure\n\nD3 has a bespoke hierarchy data structure that gives you some useful features over and above the map object seen previously.\n\nIt’s created by calling d3.hierarchy and passing in the map object generated by d3.rollup:\n\nfunction sumWorldwideGross(group) {\n  return d3.sum(group, function(d) {\n    return d.Worldwide_Gross;\n  });\n}\n\nlet groups = d3.rollup(data,\n                       sumWorldwideGross,\n                       function(d) { return d.Distributor; },\n                       function(d) { return d.Genre; }\n                      );\n\nlet root = d3.hierarchy(groups);\n\n\n\n\n\n\n  \n\n\n\n  You can also pass a nested object into d3.hierarchy. The layout examples later on use this approach.\n\n\nThe output of d3.hierarchy is a nested object that looks something like:\n\n{\n  data: [undefined, Map(3)],\n  children: [\n    {\n      data: [\"Sony Pictures\", Map(3)],\n      children: [...],\n      depth: 1,\n      height: 1,\n      parent: {...} // this item's parent node\n    }.\n    {\n      data: [\"Walt Disney Pictures\", Map(2)],\n      children: [...],\n      depth: 1,\n      height: 1,\n      parent: {...} // this item's parent node\n    }.\n    {\n      data: [\"Warner Bros.\", Map(3)],\n      children: [...],\n      depth: 1,\n      height: 1,\n      parent: {...} // this item's parent node\n    }\n  ],\n  depth: 0,\n  height: 2,\n  parent: null\n}\n\n\nIt’s similar in structure to the map object that’s passed into d3.hierarchy. The difference is that it’s a regular JavaScript object and has various properties and methods defined on it that provides additional functionality.\n\nEach item (or node) in the hierarchy has properties: data, children, depth, height and parent.\n\ndata is the associated item from the map or object that’s passed into d3.hierarchy. In this example it’s a two-element array containing the group name and the group’s value. For leaf nodes (the nodes at the bottom-most level), the value is the aggregated value (for example, the sum of Worldwide_Gross). Otherwise, it’s the map representing the items in the group. Typically you won’t need to access the value because the hierarchy makes this data available through its children and value properties.\n\nchildren is an array containing the node’s children. depth and height indicate the depth and height of the node within the hierarchy. (The root node has a depth of zero and leaf nodes have a height of zero.)\n\nparent references the node’s parent node.\n\nThe leaf nodes look something like:\n\n{\n  data: [\"Comedy\", 22498520],\n  depth: 2,\n  height: 0,\n  parent: {...} // this item's parent node\n}\n\n\nYou can see that the data property contains the rolled up value. If the rolled up value is a sum or count, it can be be propagated back up the tree using the hierachy’s .sum method:\n\nfunction sumWorldwideGross(group) {\n  return d3.sum(group, function(d) {\n    return d.Worldwide_Gross;\n  });\n}\n\nlet groups = d3.rollup(data,\n                       sumWorldwideGross,\n                       function(d) { return d.Distributor; },\n                       function(d) { return d.Genre; }\n                      );\n\nlet root = d3.hierarchy(groups);\nroot.sum(function(d) {\n  return d[1];\n});\n\n\n\n\n\n\n  \n\n\nThe .sum method takes an accessor function whose first parameter is the node’s data property. The accessor function returns the value to sum by.\n\n\n  If you’re passing the output of d3.rollup into d3.hierarchy, the accessor function will usually return d[1] which is the rolled up value generated by d3.rollup.\n\n\nEach leaf node will now have a value property equivalent to its rolled up value. For example:\n\n{\n  data: [\"Comedy\", 22498520],\n  depth: 2,\n  height: 0,\n  parent: {...}, // this item's parent node\n  value: 22498520\n}\n\n\nThe non-leaf nodes will also have a value property which is the sum of the values of its children.\n\n{\n  data: [\"Sony Pictures\", Map(3)],\n  depth: 1,\n  height: 1,\n  parent: {...}, // this item's parent node\n  value: 431672297\n}\n\n\n\n  The .value property generated by the .sum method is used by some of the layouts we’ll cover later such as treemap and packed circles.\n\n\nEach node in a D3 hierarchy has handy methods such as .descendants, .ancestors and .links.\n\n.descendants returns an array containing the node and its descendants. .ancestors returns an array containing the node and its ancestors (all the way to the root).\n\n.links returns an array of objects representing the connections between the node and its children, all the way to the leaves. We’ll see this in use later on.\n\nVisualising hierarchies\n\nThere are several ways in which hierarchies can be visualised including trees:\n\n\n\n\n\n\n  \n\n\ntreemaps:\n\n\n\n\n\n\n  \n\n\npacked circles:\n\n\n\n\n\n\n  \n\n\nand sunburst charts:\n\n\n\n\n\n\n  \n\n\n\n  You can also use stacked bar charts for visualising hierarchies!\n\n\nD3 supports the above visualisations using layout functions. These take a d3.hierarchy structure and add visual variables such as position and size to it.\n\nFor example the tree layout adds x and y values to each node such that the nodes form a tree-like shape.\n\nIn this chapter we’ll look at the tree, cluster, treemap, pack and partition layouts. Note that treemap, pack and partition are designed to lay out hierarchies where the nodes have an associated numeric value (e.g. revenue, population etc.).\n\nTree layout\n\nThe tree layout arranges the nodes of a hierarchy in a tree like arrangement.\n\n\n\n\n\n\n  \n\n\nStart by creating a tree layout function using d3.tree():\n\nvar treeLayout = d3.tree();\n\n\n  d3.tree() returns a layout function into which you can pass a hierarchy object.\n\n\nYou can configure the tree’s size using .size:\n\ntreeLayout.size([400, 200]);\n\nYou can then call treeLayout, passing in the hierarchy object root that was defined above:\n\ntreeLayout(root);\n\nThis’ll write x and y values on each node of root.\n\nTo draw the nodes:\n\n\n  use root.descendants() to get an array of all the nodes\n  join this array to circles (or any other type of SVG element)\n  use x and y to position the circles\n\n\nTo draw the links:\n\n\n  use root.links() to get an array of all the links\n  join the array to line (or path) elements\n  use x and y of the link’s source and target properties to position the line\n\n\n\n  root.links() returns an array where each element is an object containing two properties source and target which represent the link’s source and target nodes.\n\n\n// Nodes\nd3.select('svg g.nodes')\n  .selectAll('circle.node')\n  .data(root.descendants())\n  .join('circle')\n  .classed('node', true)\n  .attr('cx', function(d) {return d.x;})\n  .attr('cy', function(d) {return d.y;})\n  .attr('r', 4);\n\n// Links\nd3.select('svg g.links')\n  .selectAll('line.link')\n  .data(root.links())\n  .join('line')\n  .classed('link', true)\n  .attr('x1', function(d) {return d.source.x;})\n  .attr('y1', function(d) {return d.source.y;})\n  .attr('x2', function(d) {return d.target.x;})\n  .attr('y2', function(d) {return d.target.y;});\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n\n  For simplicity, in this and the following CodePen examples, a hierarchy object is created from a nested object (rather than from an array).\n\n\nCluster layout\n\nThe cluster layout is very similar to the tree layout the main difference being all leaf nodes are placed at the same depth.\n\nvar clusterLayout = d3.cluster()\n  .size([400, 200]);\n\nvar root = d3.hierarchy(data);\n\nclusterLayout(root);\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nTreemap layout\n\nTreemaps were invented by Ben Shneiderman to visually represent hierarchies where each item has an associated value.\n\nFor example, imagine you have country population data where each country has a region and a population value.\n\nYou can use a treemap to represent each region as a rectangle. Each region consists of smaller rectangles which represent a country. Each country is sized proportionally to the population:\n\n\n\nCreate a treemap layout function by calling d3.treemap()\t:\n\nvar treemapLayout = d3.treemap();\n\nAs before you can configure the layout:\n\ntreemapLayout\n  .size([400, 200])\n  .paddingOuter(10);\n\nBefore applying this layout to your hierarchy you must run .sum() on the hierarchy. This traverses the tree and sets .value on each node to be the sum of its children:\n\nroot.sum(function(d) {\n  return d.value;\n});\n\n\n  Note an accessor function has been passed into .sum() to specify which property to sum.\n\n\nYou can now call treemapLayout, passing in the hierarchy object root that was defined earlier:\n\ntreemapLayout(root);\n\nThe treemap layout function adds 4 properties x0, x1, y0 and y1 to each node which specify the dimensions of each rectangle in the treemap.\n\nNow you can join the nodes to rect elements and update the x, y, width and height properties of each rect:\n\nd3.select('svg g')\n  .selectAll('rect')\n  .data(root.descendants())\n  .join('rect')\n  .attr('x', function(d) { return d.x0; })\n  .attr('y', function(d) { return d.y0; })\n  .attr('width', function(d) { return d.x1 - d.x0; })\n  .attr('height', function(d) { return d.y1 - d.y0; })\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nIf you’d like labels in each rectangle you can join g elements to the array and add rect and text elements to each g:\n\nvar nodes = d3.select('svg g')\n  .selectAll('g')\n  .data(rootNode.descendants())\n  .join('g')\n  .attr('transform', function(d) {return 'translate(' + [d.x0, d.y0] + ')'})\n\nnodes\n  .append('rect')\n  .attr('width', function(d) { return d.x1 - d.x0; })\n  .attr('height', function(d) { return d.y1 - d.y0; })\n\nnodes\n  .append('text')\n  .attr('dx', 4)\n  .attr('dy', 14)\n  .text(function(d) {\n    return d.data.name;\n  })\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\ntreemap layouts can be configured in a number of ways:\n\n\n  the padding around a node’s children can be set using .paddingOuter\n  the padding between sibling nodes can be set using .paddingInner\n  outer and inner padding can be set at the same time using .padding\n  the outer padding can also be fine tuned using .paddingTop, .paddingBottom, .paddingLeft and .paddingRight.\n\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nIn the above example paddingTop is 20 and paddingInner is 2.\n\nTreemaps have more than one strategy for arranging the rectangles. D3 has a few built-in ones such as treemapBinary, treemapDice, treemapSlice, treemapSliceDice and  treemapSquarify.\n\ntreemapBinary strives for a balance between horizontal and vertical partitions, treemapDice partitions horizontally, treemapSlice partitions vertically, treemapSliceDice alternates between horizontal and vertical partioning and treemapSquarify allows the aspect ratio of the rectangles to be influenced.\n\nYou can select a tiling strategy using the .tile method:\n\ntreemapLayout.tile(d3.treemapDice)\n\n\n\n\n\n\n  \n\n\nThe effect of different squarify ratios can be seen here.\n\nPack layout\n\nThe pack layout is similar to the tree layout but circles are used to represent nodes.\n\nIn this example each country is represented by a circle (sized according to population) and the countries are grouped by region.\n\n\n\nCreate a pack layout function using d3.pack():\n\nvar packLayout = d3.pack();\n\nAs before you can configure its size by passing an array [width, height] into the .size method:\n\npackLayout.size([300, 300]);\n\nAs with the treemap you must call .sum() on the hierarchy object root before applying the pack layout:\n\nrootNode.sum(function(d) {\n  return d.value;\n});\n\npackLayout(rootNode);\n\nThe pack layout adds x, y and r (for radius) properties to each node.\n\nNow you can join circle elements to each descendant of root:\n\nd3.select('svg g')\n  .selectAll('circle')\n  .data(rootNode.descendants())\n  .join('circle')\n  .attr('cx', function(d) { return d.x; })\n  .attr('cy', function(d) { return d.y; })\n  .attr('r', function(d) { return d.r; })\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nLabels can be added by creating g elements for each descendant:\n\nvar nodes = d3.select('svg g')\n  .selectAll('g')\n  .data(rootNode.descendants())\n  .join('g')\n  .attr('transform', function(d) {return 'translate(' + [d.x, d.y] + ')'})\n\nnodes\n  .append('circle')\n  .attr('r', function(d) { return d.r; })\n\nnodes\n  .append('text')\n  .attr('dy', 4)\n  .text(function(d) {\n    return d.children === undefined ? d.data.name : '';\n  })\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nThe padding around each circle can be configured using .padding():\n\npackLayout.padding(10)\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nPartition layout\n\nThe partition layout subdivides a rectangular space into layers, each of which represents a layer in the hierarchy. Each layer is further subdivided for each node in the layer:\n\n\n\nCreate a partition layout function using d3.partition():\n\nvar partitionLayout = d3.partition();\n\nAs before you can configure its size by passing an array [width, height] into the .size method:\n\npartitionLayout.size([400, 200]);\n\nAs with the treemap you must call .sum() on the hierarchy object root and before applying the partition layout:\n\nrootNode.sum(function(d) {\n  return d.value;\n});\n\npartitionLayout(rootNode);\n\nThe partition layout adds x0, x1, y0 and y1 properties to each node.\n\nYou can now join rect elements to each descendant of root:\n\nd3.select('svg g')\n  .selectAll('rect')\n  .data(rootNode.descendants())\n  .join('rect')\n  .attr('x', function(d) { return d.x0; })\n  .attr('y', function(d) { return d.y0; })\n  .attr('width', function(d) { return d.x1 - d.x0; })\n  .attr('height', function(d) { return d.y1 - d.y0; });\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nPadding can be added between nodes using .padding():\n\npartitionLayout.padding(2);\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nIf you’d like to change the orientation of the partition layout so that the layers run left to right you can swap x0 with y0 and x1 with y1 when defining the rect elements:\n\n  .attr('x', function(d) { return d.y0; })\n  .attr('y', function(d) { return d.x0; })\n  .attr('width', function(d) { return d.y1 - d.y0; })\n  .attr('height', function(d) { return d.x1 - d.x0; });\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nYou can also map the x dimension into a rotation angle and y into a radius to create a sunburst partition:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n\n  ",
	"\n  \tThis article explains how to visualise links (or flows) between a group of nodes using D3.js.\n\nChord diagrams visualise links (or flows) between a group of nodes, where each flow has a numeric value. For example, they can show migration flows between countries. (Personally I find them difficult to interpret!)\n\nThe data needs to be in the form of an n x n matrix (where n is the number of items):\n\nvar data = [\n  [10, 20, 30],\n  [40, 60, 80],\n  [100, 200, 300]\n];\n\nThe first row represents flows from the 1st item to the 1st, 2nd and 3rd items etc.\n\nYou create the layout using:\n\nvar chordGenerator = d3.chord();\n\nand you configure it using .padAngle() (to set the angle between adjacent groups in radians), .sortGroups() (to specify the order of the groups), .sortSubgroups() (to sort within each group) and .sortChords() to determine the z order of the chords.\n\nApply the layout using:\n\nvar chords = chordGenerator(data);\n\nwhich returns an array of chords. Each element of the array is an object with source and target properties. Each source and target has startAngle and endAngle properties which will define the shape of each chord.\n\nWe use the ribbon shape generator which converts the chord properties into path data (see the Shapes chapter for more information on shape generators).\n\nvar ribbonGenerator = d3.ribbon().radius(200);\n\nd3.select('g')\n  .selectAll('path')\n  .data(chords)\n  .join('path')\n  .attr('d', ribbonGenerator)\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n\n  ",
	"\n  \tD3’s force layout uses physics based rules to position visual elements. This article shows how to use D3’s force layout and how to use it to create network visualisations and circle clusters.\n\nD3’s force layout uses a physics based simulator for positioning visual elements.\n\nForces can be set up between elements, for example:\n\n\n  all elements can be configured to repel one another\n  elements can be attracted to center(s) of gravity\n  linked elements can be set a fixed distance apart (e.g. for network visualisation)\n  elements can be configured to avoid intersecting one another (collision detection)\n\n\nThe force layout allows us to position elements in a way that would be difficult to achieve using other means.\n\nHere’s an example of a force layout: we have a number of circles (each of which has a category A, B or C) and we add the following forces:\n\n\n  all circles attract one another (to clump circles together)\n  collision detection (to stop circles overlapping)\n  circles are attracted to one of three centers (A, B or C)\n\n\n\n\n\n\n\n  \n\n\nThe force layout requires a larger amount of computation (typically requiring a few seconds of time) than other D3 layouts and and the solution is calculated in a step by step (iterative) manner. Usually the positions of the SVG/HTML elements are updated as the simulation iterates, which is why we see the circles jostling into position.\n\nSetting up a force simulation\n\nBroadly speaking there are 4 steps to setting up a force simulation:\n\n\n  create an array of objects\n  call forceSimulation, passing in the array of objects\n  add one or more force functions (e.g. forceManyBody, forceCenter, forceCollide) to the system\n  set up a callback function to update the element positions after each tick\n\n\nLet’s start with a minimal example:\n\nvar width = 300, height = 300\nvar nodes = [{}, {}, {}, {}, {}]\n\nvar simulation = d3.forceSimulation(nodes)\n  .force('charge', d3.forceManyBody())\n  .force('center', d3.forceCenter(width / 2, height / 2))\n  .on('tick', ticked);\n\nHere we’ve created a simple array of 5 objects and have added two force functions forceManyBody and forceCenter to the system. (The first of these makes the elements repel each other while the second attracts the elements towards a centre point.)\n\nEach time the simulation iterates the function ticked will be called. This function joins the nodes array to circle elements and updates their positions:\n\nfunction ticked() {\n  var u = d3.select('svg')\n    .selectAll('circle')\n    .data(nodes)\n    .join('circle')\n    .attr('r', 5)\n    .attr('cx', function(d) {\n      return d.x\n    })\n    .attr('cy', function(d) {\n      return d.y\n    });\n}\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nThe power and flexibility of the force simulation is centred around force functions which adjust the position and velocity of elements to achieve a number of effects such as attraction, repulstion and collision detection.\n\nYou can define your own force functions but D3 comes with a number of useful ones built in:\n\n\n  forceCenter (for setting the center of gravity of the system)\n  forceManyBody (for making elements attract or repel one another)\n  forceCollide (for preventing elements overlapping)\n  forceX and forceY (for attracting elements to a given point)\n  forceLink (for creating a fixed distance between connected elements)\n\n\nForce functions are added to the simulation using .force() where the first argument is a user defined id and the second argument the force function:\n\nsimulation.force('charge', d3.forceManyBody())\n\nLet’s look at the built-in force functions one by one.\n\nforceCenter\n\nforceCenter is useful (if not essential) for centering your elements as a whole about a center point. (Without it elements might disappear off the page.)\n\nIt can either be initialised with a center position:\n\nd3.forceCenter(100, 100)\n\nor using the configuration functions .x() and .y():\n\nd3.forceCenter().x(100).y(100)\n\nYou can add it to the system using:\n\nsimulation.force('center', d3.forceCenter(100, 100))\n\nSee the next example (forceManyBody) for an example implementation.\n\nforceManyBody\n\nforceManyBody causes all elements to attract or repel one another. The strength of the attraction or repulsion can be set using .strength() where a positive value will cause elements to attract one another while a negative value causes elements to repel each other. The default value is -30.\n\nsimulation.force('charge', d3.forceManyBody().strength(-20))\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n\n  When creating network diagrams we typically want the elements to repel one another but for visualisations where elements are clumped together, attractive forces are necessary.\n\n\nforceCollide\n\nforceCollide is used to stop circular elements overlapping and is particularly useful when ‘clumping’ circles together.\n\nThe radius of the elements is specified by passing an accessor function into forceCollide’s .radius method. This function’s first parameter d is the joined data from which you can derive the radius.\n\nFor example:\n\nvar numNodes = 100\nvar nodes = d3.range(numNodes).map(function(d) {\n  return {radius: Math.random() * 25}\n})\n\nvar simulation = d3.forceSimulation(nodes)\n  .force('charge', d3.forceManyBody().strength(5))\n  .force('center', d3.forceCenter(width / 2, height / 2))\n  .force('collision', d3.forceCollide().radius(function(d) {\n    return d.radius\n  }))\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nIn this example, forceManyBody pushes all the nodes together, forceCenter helps keep the nodes in the center of the container and forceCollide stops the nodes intersecting.\n\nforceX and forceY\n\nforceX and forceY cause elements to be attracted towards specified position(s). We can use a single center for all elements or apply the force on a per-element basis. The strength of attraction can be configured using .strength().\n\nFor example suppose you have a number of elements, each of which has a property category that has value 0, 1 or 2. You can add a forceX force function to attract the elements to an x-coordinate of 100, 300 or 500 based on the element’s category:\n\nvar xCenter = [100, 300, 500];\n\nvar simulation = d3.forceSimulation(nodes)\n  .force('charge', d3.forceManyBody().strength(5))\n  .force('x', d3.forceX().x(function(d) {\n    return xCenter[d.category];\n  }))\n  .force('collision', d3.forceCollide().radius(function(d) {\n    return d.radius;\n  }));\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nIn this example, forceManyBody pushes all the nodes together, forceX attracts the nodes to particular x-coordinates and forceCollide stops the nodes intersecting.\n\nIf our data has a numeric dimension we can use forceX or forceY to position elements along an axis:\n\nvar simulation = d3.forceSimulation(nodes)\n  .force('charge', d3.forceManyBody().strength(5))\n  .force('x', d3.forceX().x(function(d) {\n    return xScale(d.value);\n  }))\n  .force('y', d3.forceY().y(function(d) {\n    return 0;\n  }))\n  .force('collision', d3.forceCollide().radius(function(d) {\n    return d.radius;\n  }));\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n\n  Use the above with caution because the x position of the elements is not guaranteed to be exact.\n\n\nforceLink\n\nforceLink pushes linked elements to be a fixed distance apart. It requires an array of links that specify which elements you’d like to link together. Each link object specifies a source and target element, where the value is the element’s array index:\n\nvar links = [\n  {source: 0, target: 1},\n  {source: 0, target: 2},\n  {source: 0, target: 3},\n  {source: 1, target: 6},\n  {source: 3, target: 4},\n  {source: 3, target: 7},\n  {source: 4, target: 5},\n  {source: 4, target: 7}\n]\n\nYou can then pass your links array into the forceLink function using .links():\n\nvar simulation = d3.forceSimulation(nodes)\n  .force('charge', d3.forceManyBody().strength(-100))\n  .force('center', d3.forceCenter(width / 2, height / 2))\n  .force('link', d3.forceLink().links(links));\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nIn this example, forceManyBody pushes the nodes apart, forceCenter helps keep the nodes centered with the container and forceLink maintains a constant distance between linked nodes.\n\nThe distance and strength of the linked elements can be configured using .distance() (default value is 30) and .strength().\n\n\n  ",
	"\n  \tD3’s geo module helps you create maps from GeoJSON data. This article explains GeoJSON, projections and path generators. It also shows how to use these three concepts to create maps.\n\nThis chapter looks at D3’s approach to rendering geographic information.\n\nAs an example, the globe below is drawn using D3. A GeoJSON file is loaded and D3 is used to project the geographic data and draw it on a Canvas element:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nD3’s approach differs to so called raster methods such as Leaflet and Google Maps. These pre-render map features as image tiles and these are loaded from a web server and pieced together in the browser to form a map.\n\nTypically D3 requests vector geographic information in the form of GeoJSON and renders this to SVG or Canvas in the browser.\n\nRaster maps often look more like traditional print maps where a lot of detail (e.g. place names, roads, rivers etc.) can be shown without an impact on performance. However, dynamic content such as animation and interaction is more easily implemented using a vector approach. (It’s also quite common to combine the two approaches.)\n\nD3 mapping concepts\n\nThe 3 concepts that are key to understanding map creation using D3 are:\n\n\n  GeoJSON (a JSON-based format for specifying geographic data)\n  projections (functions that convert from latitude/longitude co-ordinates to x & y co-ordinates)\n  geographic path generators (functions that convert GeoJSON shapes into SVG or Canvas paths)\n\n\nGeoJSON\n\nGeoJSON is a standard for representing geographic data using the JSON format and the full specification is at geojson.org.\n\nHere’s a typical GeoJSON object:\n\n{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {\n        \"name\": \"Africa\"\n      },\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [[[-6, 36], [33, 30], ... , [-6, 36]]]\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"properties\": {\n        \"name\": \"Australia\"\n      },\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [[[143, -11], [153, -28], ... , [143, -11]]]\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"properties\": {\n        \"name\": \"Timbuktu\"\n      },\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [-3.0026, 16.7666]\n      }\n    }\n  ]\n}\n\nIn the above object there’s a FeatureCollection containing an array of 3 features:\n\n\n  Africa\n  Australia\n  the city of Timbuktu\n\n\nEach feature consists of geometry (simple polygons in the case of the countries and a point for Timbuktu) and properties.\n\nProperties can contain any information about the feature such as name, id, and other data such as population, GDP etc.\n\nD3 takes care of most of the detail when rendering GeoJSON so you only need a basic understanding of GeoJSON to get started with D3 mapping.\n\nProjections\n\nA projection function takes a longitude and latitude co-ordinate (in the form of an array [lon, lat]) and transforms it into an x and y co-ordinate:\n\nfunction projection( lonLat ) {\n  let x = ... // some formula here to calculate x\n  let y = ... // some formula here to calculate y\n  return [x, y];\n}\n\nprojection( [-3.0026, 16.7666] )\n// returns [474.7594743879618, 220.7367625635119]\n\nProjection mathematics can get quite complex but fortunately D3 provides a large number of projection functions.\n\nFor example you can create an equi-rectangular projection function using:\n\nlet projection = d3.geoEquirectangular();\n\nprojection( [-3.0026, 16.7666] )\n// returns [474.7594743879618, 220.7367625635119]\n\nWe’ll look at projections in more detail later.\n\nGeographic path generators\nA geographic path generator is a function that takes a GeoJSON object and converts it into an SVG path string. (In fact, it’s just another type of shape generator.)\n\nYou can create a generator using the method .geoPath and configure it with a projection function:\n\nlet projection = d3.geoEquirectangular();\n\nlet geoGenerator = d3.geoPath()\n  .projection(projection);\n\nlet geoJson = {\n  \"type\": \"Feature\",\n  \"properties\": {\n    \"name\": \"Africa\"\n  },\n  \"geometry\": {\n    \"type\": \"Polygon\",\n    \"coordinates\": [[[-6, 36], [33, 30], ... , [-6, 36]]]\n  }\n}\n\ngeoGenerator(geoJson);\n// returns \"M464.0166237760863,154.09974265651798L491.1506253268278,154.8895088551978 ... L448.03311471280136,183.1346693994119Z\"\n\nAs usual with shape generators the generated path string is used to set the d attribute on an SVG path element.\n\nPutting it all together\n\nGiven some GeoJSON, a projection function and a geographic path generator you can create a basic map:\n\nlet geoJson = {\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {\n        \"name\": \"Africa\"\n      },\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [[[-6, 36], [33, 30], ... , [-6, 36]]]\n      }\n    },\n    ...\n  ]\n}\n\nlet projection = d3.geoEquirectangular();\n\nlet geoGenerator = d3.geoPath()\n  .projection(projection);\n\n// Join the FeatureCollection's features array to path elements\nlet u = d3.select('#content g.map')\n  .selectAll('path')\n  .data(geojson.features)\n  .join('path')\n  .attr('d', geoGenerator);\n\ngeoJson.features is an array of features. This array is joined to path elements. The d attribute is set using the function geoGenerator. This receives a feature as its first parameter and outputs a path string.\n\nThe last line may look like magic but is the equivalent of:\n\n  .attr('d', function(d) {\n    return geoGenerator(d);\n  });\n\n\nIn this case the parameter d is a GeoJSON feature.\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n\n  To keep things simple the GeoJSON in the above example uses just a few co-ordinates to define the country boundaries.\n\n\nThe above example shows the essence of creating maps using D3 and I recommend spending time to understand each concept (GeoJSON, projections and geo generators) and how they fit together.\n\nNow that we’ve covered the basics we’ll look at each concept in more detail.\n\nGeoJSON\n\nGeoJSON is a JSON-based structure for specifying geographic data. More often than not it’s converted from shapefile data (a geospatial vector data format widely used in the GIS field) using tools such as mapshaper, ogr2ogr, shp2json or QGIS.\n\nA popular source of world map shapefiles is Natural Earth and if starting out I recommend trying out mapshaper for importing shapefiles and exporting as GeoJSON. It can also filter by properties (e.g. if you wanted to filter countries by continent). For a more in depth look at conversion look at Mike Bostock’s Let’s Make a Map tutorial.\n\nYou can create maps without understanding the GeoJSON specification in minute detail because tools such as mapshaper and D3 do such a good job of abstracting away the detail. However, if you did want to understand GeoJSON in greater depth I recommend checking out the official specification.\n\nSo far we’ve embedded a GeoJSON object in our example files. In practice the GeoJSON would be in a separate file and loaded using an ajax request. We cover requests in more detail in the requests chapter but for the remainder of this chapter we’ll load a GeoJSON file using:\n\nd3.json('ne_110m_land.json', function(err, json) {\n  createMap(json);\n})\n\nIt’s worth mentioning TopoJSON which is another JSON based standard for describing geographic data and tends to result in significantly smaller file sizes. It requires a bit more work to use, and we don’t cover it in this chapter. However for further information check out the documentation.\n\nProjections\n\nThere are numerous (if not infinite) ways of converting (or ‘projecting’) a point on a sphere (e.g. the earth) to a point on a flat surface (e.g. a screen) and people have written countless articles (such as this one) on the pros and cons of different projections.\n\nIn short there is no perfect projection as every projection will distort shape, area, distance and/or direction. Choosing a projection is a case of choosing which property you don’t want to be distorted and accepting that there’ll be distortion in the other properties (or choose a projection that strives for a balanced approach). For example, if it’s important that the size of countries are represented accurately then  choose a projection that strives to preserve area (probably to the cost of shape, distance and direction).\n\nD3 has a number of core projections that should cover most use cases:\n\n\n  geoAzimuthalEqualArea\n  geoAzimuthalEquidistant\n  geoGnomonic\n  geoOrthographic\n  geoStereographic\n  geoAlbers\n  geoConicConformal\n  geoConicEqualArea\n  geoConicEquidistant\n  geoEquirectangular\n  geoMercator\n  geoTransverseMercator\n\n\nSome projections preserve area (e.g. geoAzimuthalEqualArea & geoConicEqualArea), others distance (e.g. geoAzimuthalEquidistant & geoConicEquidistant) and others relative angles (e.g. geoEquirectangular & geoMercator). For a more in depth discussion of the pros and cons of each projection try resources such as Carlos A. Furuti’s Map Projection Pages.\n\nThe grid below shows each core projection on a world map together with a longitude/latitude grid and equal radius circles.\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nProjection functions\n\nA projection function takes input [longitude, latitude] and outputs a pixel co-ordinate [x, y].\n\n\n  Be careful to note the order of longitude and latitude in the above array!\n\n\nYou’re free to write your own projection functions but much easier is to ask D3 to make one for you. To do this  choose a projection method (e.g. d3.geoAzimuthalEqualArea), call it and it’ll return a projection function:\n\nlet projection = d3.geoAzimuthalEqualArea();\n\nprojection( [-3.0026, 16.7666] );\n// returns [473.67353385539417, 213.6120079887163]\n\nThe core projections have configuration functions for setting the following parameters:\n\n\n  scaleScale factor of the projection\n  centerProjection center [longitude, latitude]\n  translatePixel [x,y] location of the projection center\n  rotateRotation of the projection [lambda, phi, gamma] (or [yaw, pitch, roll])\n\n\nThe precise meaning of each parameter is dependent on the mathematics behind each projection but broadly speaking:\n\n\n  scale specifies the scale factor of the projection. The higher the number the larger the map.\n  center specifies the center of projection (with a [lon, lat] array)\n  translate specifies where the center of projection is located on the screen (with a [x, y] array)\n  rotate specifies the rotation of the projection (with a [λ, φ, γ] array)  where the parameters correspond to yaw, pitch and roll, respectively:\n\n\n\n\nFor example you can create and configure a projection function such that Timbuktu is centred in a 960x500 map using:\n\nlet projection = d3.geoAzimuthalEqualArea()\n  .scale(300)\n  .center([-3.0026, 16.7666])\n  .translate([480, 250]);\n\nTo get a feel for how each parameter behaves use the projection explorer below. The (equal radius) circles and grid allow you to assess the projection’s distortion of area and angle.\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n.invert()\n\nYou can convert a pixel co-ordinate [x, y] to a longitude/latitude array using the projection’s .invert() method:\n\nlet projection = d3.geoAzimuthalEqualArea();\n\nprojection( [-3.0026, 16.7666] )\n// returns [473.67353385539417, 213.6120079887163]\n\nprojection.invert( [473.67353385539417, 213.6120079887163] )\n// returns [-3.0026, 16.766]\n\nFitting\n\nGiven a GeoJSON object, a projection’s .fitExtent() method sets the projection’s scale and translate such that the geometry fits within a given bounding box:\n\nprojection.fitExtent([[0, 0], [900, 500]], geojson);\n\nThe first argument of .fitExtent is an array containing two coordinates: the top left point ([x, y]) of the bounding box and the size ([width, height]) of the bounding box. The second argument is a GeoJSON object.\n\nIn the example below the canvas element has a light grey background and the bounding box into which we’re fitting the geoJSON is shown as a dotted outline. The following code is used to fit the geometry within the bounding box:\n\nprojection.fitExtent([[20, 20], [620, 420]], geojson);\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nIf your bounding box’s top left corner is at [0, 0] you can omit the top left coordinate and just supply the width and height:\n\nprojection.fitSize([900, 500], geojson);\n\nGeographic path generators\n\nA geographic path generator is a function that transforms GeoJSON into an SVG path string (or into canvas element calls):\n\ngeoGenerator(geoJson);\n// e.g. returns a SVG path string \"M464.01,154.09L491.15,154.88 ... L448.03,183.13Z\"\n\nYou create the generator using d3.geoPath() and must configure it’s projection type:\n\nlet projection = d3.geoEquirectangular();\n\nlet geoGenerator = d3.geoPath()\n  .projection(projection);\n\nYou can now use the generator to help create an SVG or canvas map. The SVG option is a bit easier to implement, especially when it comes to user interaction (because event handlers and hover states can be added).\n\nThe canvas approach requires a bit more work but is typically faster to render (and more memory efficient).\n\nRendering SVG\nTo render an SVG map you:\n\n\n  join a GeoJSON features array to SVG path elements\n  update each path element’s d attribute using the geographic path generator\n\n\nFor example:\n\nlet geoJson = {\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {\n        \"name\": \"Africa\"\n      },\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [[[-6, 36], [33, 30], ... , [-6, 36]]]\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"properties\": {\n        \"name\": \"Australia\"\n      },\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [[[143, -11], [153, -28], ... , [143, -11]]]\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"properties\": {\n        \"name\": \"Timbuktu\"\n      },\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [-3.0026, 16.7666]\n      }\n    }\n  ]\n}\n\nlet projection = d3.geoEquirectangular();\n\nlet geoGenerator = d3.geoPath()\n  .projection(projection);\n\n// Join the FeatureCollection's features array to path elements\nlet u = d3.select('#content g.map')\n  .selectAll('path')\n  .data(geojson.features)\n  .join('path')\n  .attr('d', geoGenerator);\n\ngeoJson.features is an array of features. This array is joined to path elements. The d attribute is set using the function geoGenerator. This receives a feature as its first parameter and outputs a path string.\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nRendering to canvas\n\nTo render to a canvas element you pass the canvas DOM element into the generator’s context method:\n\nlet context = d3.select('#content canvas')\n  .node()\n  .getContext('2d');\n\nlet geoGenerator = d3.geoPath()\n  .projection(projection)\n  .context(context);\n\n\n  The .node method returns the first DOM element of a selection.\n\n\nYou then begin a canvas path (using context.beginPath()) and call geoGenerator which will produce the necessary canvas calls:\n\ncontext.beginPath();\ngeoGenerator({type: 'FeatureCollection', features: geojson.features})\ncontext.stroke();\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nLines and arcs\n\nThe geographic path generator is clever enough to distinguish between polygonal (typically for geographic areas) and point (typically for lon/lat locations) features. As can be seen in the above examples it renders polygons as line segments and points as arcs.\n\nYou can set the radius of the circles using .pointRadius():\n\nlet geoGenerator = d3.geoPath()\n  .pointRadius(5)\n  .projection(projection);\n\nPath geometry\n\nThe geographic path generator can also be used to compute the area (in pixels), centroid, bounding box and path length (in pixels) of a projected GeoJSON feature:\n\nlet feature = geojson.features[0];\n\n// Compute the feature's area (in pixels)\ngeoGenerator.area(feature);\n// returns 30324.86518469876\n\n// Compute the feature's centroid (in pixel co-ordinates)\ngeoGenerator.centroid(feature);\n// returns [266.9510120424504, 127.35819206325564]\n\n// Compute the feature's bounds (in pixel co-ordinates)\ngeoGenerator.bounds(feature);\n// returns [[140.6588054321928, 24.336293856408275], [378.02358370342165, 272.17304763960306]]\n\n// Compute the path length (in pixels)\ngeoGenerator.measure(feature);\n// returns 775.7895349902461\n\nThis example shows the area and length of a hovered path. It also draws the path’s centroid and bounding box:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nShapes\n\nIf you need to add lines and/or circles to a map you can add features to the GeoJSON.\n\nLines can be added as a LineString feature and will be projected into great-arcs (i.e. the shortest distance across the surface of the globe).\n\nHere’s an example where a line is added between London and New York:\n\ngeoGenerator({\n  type: 'Feature',\n  geometry: {\n    type: 'LineString',\n    coordinates: [[0.1278, 51.5074], [-74.0059, 40.7128]]\n  }\n});\n\nCircle features can be generated using d3.geoCircle(). This creates a circle generator which returns a GeoJSON object representing a circle.\n\nTypically the center ([lon, lat]) and the radius (in degrees) are set:\n\nlet circleGenerator = d3.geoCircle()\n  .center([0.1278, 51.5074])\n  .radius(5);\n\nlet circle = circleGenerator();\n// returns a GeoJSON object representing a circle\n\ngeoGenerator(circle);\n// returns a path string representing the projected circle\n\nA GeoJSON grid of longitude and latitude lines (known as a graticule) can be generated using d3.graticule(). This creates a graticule generator which returns a GeoJSON object representing the graticules:\n\nlet graticuleGenerator = d3.geoGraticule();\n\nlet graticules = graticuleGenerator();\n// returns a GeoJSON object representing the graticule\n\ngeoGenerator(graticules);\n// returns a path string representing the projected graticule\n\n(See the official documentation for detailed information on graticule configuration.)\n\nHere’s an example where a line, a circle and graticules are added to a map:\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\nSpherical geometry\n\nThere’s a handful of D3 methods that may come in useful from time to time. The first of these .geoArea(), .geoBounds(), .geoCentroid(), .geoDistance() and geoLength() are similar to the path geometry methods described above but operate in spherical space.\n\nInterpolation\n\nThe d3.geoInterpolate() method creates a function that accepts input between 0 and 1 and interpolates between two [lon, lat] locations:\n\nlet londonLonLat = [0.1278, 51.5074];\nlet newYorkLonLat = [-74.0059, 40.7128];\nlet geoInterpolator = d3.geoInterpolate(londonLonLat, newYorkLonLat);\n\ngeoInterpolator(0);\n// returns [0.1278, 51.5074]\n\ngeoInterpolator(0.5);\n// returns [-41.182023242967695, 52.41428456719971] (halfway between the two locations)\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\ngeoContains\n\nIf you’re using a canvas element to render your geometry you don’t have the luxury of being able to add event handlers onto SVG path elements. Instead you can check whether mouse or touch events occur inside the boundary of a feature. You can do this using d3.geoContains which accepts a GeoJSON feature and a [lon, lat] array and returns a boolean:\n\nd3.geoContains(ukFeature, [0.1278, 51.5074]);\n// returns true\n\n\n\n\n\n\n  \n\n\n\n\n\t\n\t\n\t\n\n\n\n\n  ",
	"\n  \tHow to request and parse CSV and JSON data using D3 requests.\n\nAny time a web browser wishes to request a resource, be it an HTML file, a JPEG image or a CSV file, it uses an HTTP request.\n\n\n  For the purposes of this chapter you don’t need to understand HTTP requests in detail but if you wish to learn more I recommend Codecademy’s guide.\n\n\nTypically the data (or resource) you wish to request will have a URL (Uniform Resource Locator) such as https://assets.codepen.io/2814973/my-csv.csv.\n\n\n  The URL can also be relative to the index.html of your web application so it might look like data/my-csv.csv\n\n\nD3 requests\n\nD3 makes requesting data relatively simple. It deals with the HTTP request and can also transform the incoming data into a useful format. For example it can request a CSV (comma separated value) file and transform it into an array of objects.\n\nThis chapter will focus on requesting common data formats namely CSV, TSV and JSON. When building data visualisations these are the only formats I use.\n\nRequesting CSV data\n\nCSV files are text files containing tabular data. For example:\n\nrank,workers,company,state_l,city,growth,revenue,industry\n1,227,Fuhu,California,El Segundo,158956.9106,195640000,Consumer Products & Services\n2,191,Quest Nutrition,California,El Segundo,57347.9246,82640563,Food & Beverage\n3,145,Reliant Asset Management,Virginia,Arlington,55460.1646,85076502,Business Products & Services\n4,62,Superfish,California,Palo Alto,26042.963,35293000,Software\n5,92,Acacia Communications,Massachusetts,Maynard,20690.4578,77652360,Telecommunications\n...\n\n\nYou typically export CSV files from spreadsheets and databases. Much of the open data you find on the web is also in CSV format.\n\nTypically (but not always) the first line contains the names of each field (rank, workers, company etc.). The remaining lines contain the data. Each value is separated by a comma.\n\nYou can use d3.csv to request a CSV file:\n\nd3.csv('https://assets.codepen.io/2814973/Inc5000+Company+List_2014-top250.csv')\n  .then(function(data) {\n    console.log(data);\n  });\n\nd3.csv accepts the URL as its first parameter and returns a promise object.\n\nA promise object represents an asynchronous operation. An asynchronous operation is an operation whose result is some time in the future. This means that your code can continue to run immediately after initiating the request.\n\nWhen the browser receives the requested data, the promise is fulfilled and the function that’s passed into the promise’s .then method is called.\n\n\n  You don’t need to fully understand promises to use d3.csv. The main thing to remember is to pass a callback function into the .then method. The callback method is called when the file arrives. Its first parameter is the data.\n\n\nWhen the request is fulfilled, D3 converts the incoming CSV file into an array of objects. Each object represents a row of data:\n\n[\n  {\n    \"rank\": \"1\",\n    \"workers\": \"227\",\n    \"company\": \"Fuhu\",\n    \"state_l\": \"California\",\n    \"city\": \"El Segundo\",\n    \"growth\": \"158956.9106\",\n    \"revenue\": \"195640000\",\n    \"industry\": \"Consumer Products & Services\"\n  },\n  {\n    \"rank\": \"2\",\n    \"workers\": \"191\",\n    \"company\": \"Quest Nutrition\",\n    \"state_l\": \"California\",\n    \"city\": \"El Segundo\",\n    \"growth\": \"57347.9246\",\n    \"revenue\": \"82640563\",\n    \"industry\": \"Food & Beverage\"\n  },\n  {\n    \"rank\": \"3\",\n    \"workers\": \"145\",\n    \"company\": \"Reliant Asset Management\",\n    \"state_l\": \"Virginia\",\n    \"city\": \"Arlington\",\n    \"growth\": \"55460.1646\",\n    \"revenue\": \"85076502\",\n    \"industry\": \"Business Products & Services\"\n  },\n  ...\n]\n\n\n  d3.csv assumes the first row contains field names.\n\n  Note that all the numbers are represented by strings. We’ll show how to convert these back to numbers later on.\n\n\nThe above array can be joined to HTML or SVG elements. For example:\n\nfunction update(data) {\n  d3.select('#content tbody')\n    .selectAll('tr')\n    .data(data)\n    .join('tr')\n    .html(function(d) {\n      let html = '<tr>';\n      html += '<td>' + d.company + '</td>';\n      html += '<td>' + d.industry + '</td>';\n      html += '<td>' + d.revenue + '</td>';\n      html += '<td>' + d.workers + '</td>';\n      html += '</tr>';\n      return html;\n    });\n}\n\nd3.csv('https://assets.codepen.io/2814973/Inc5000+Company+List_2014-top250.csv')\n  .then(function(data) {\n    update(data);\n  });\n\n\n\n\n\n\n  \n\n\nRow conversion\n\nAs pointed out previously, D3 interprets numbers in the CSV file as strings.\n\nYou can convert strings to numbers at any point in your code but I recommend doing the conversion straightaway. This can be done by passing a function into d3.csv as the second argument. The function is called on each row of data and you return a new object with any appropriate transformations.\n\nIn this example we convert strings to numbers (where appropriate) and rename some of the variable names:\n\nfunction convertRow(d) {\n  return {\n    rank: +d.rank,\n    workers: +d.workers,\n    name: d.company,\n    state: d.state_l,\n    city: d.city,\n    growth: +d.growth,\n    revenue: +d.revenue,\n    sector: d.industry\n  }\n}\n\nd3.csv('https://assets.codepen.io/2814973/Inc5000+Company+List_2014-top250.csv', convertRow)\n  .then(function(data) {\n    console.log(data);\n  });\n\n\n  The + operator converts a string to a number.\n\n\nNow the array of data looks like:\n\n[\n  {\n    \"rank\": 1,\n    \"workers\": 227,\n    \"name\": \"Fuhu\",\n    \"state\": \"California\",\n    \"city\": \"El Segundo\",\n    \"growth\": 158956.9106,\n    \"revenue\": 195640000,\n    \"sector\": \"Consumer Products & Services\"\n  },\n  {\n    \"rank\": 2,\n    \"workers\": 191,\n    \"name\": \"Quest Nutrition\",\n    \"state\": \"California\",\n    \"city\": \"El Segundo\",\n    \"growth\": 57347.9246,\n    \"revenue\": 82640563,\n    \"sector\": \"Food & Beverage\"\n  },\n  {\n    \"rank\": 3,\n    \"workers\": 145,\n    \"name\": \"Reliant Asset Management\",\n    \"state\": \"Virginia\",\n    \"city\": \"Arlington\",\n    \"growth\": 55460.1646,\n    \"revenue\": 85076502,\n    \"sector\": \"Business Products & Services\"\n  },\n  ...\n]\n\nRequesting TSV data\n\nTSV data is tab separated value data and is treated in a similar manner to CSV. Use d3.tsv to load TSV data.\n\nRequesting JSON data\n\nJSON is a file format that closely mirrors JavaScript arrays and objects. It allows for nested structures which gives it an edge over tabular file formats. JSON is commonly used as a file format by APIs.\n\nHere’s an example of a JSON file that’s located at https://assets.codepen.io/2814973/my-json.json:\n\n[\n  {\n    \"name\": \"Paris\",\n    \"indicator1\": 4030,\n    \"indicator2\": 13.45\n  },\n  {\n    \"name\": \"Tokyo\",\n    \"indicator1\": 3912,\n    \"indicator2\": 45.41\n  },\n  {\n    \"name\": \"New York\",\n    \"indicator1\": 19481,\n    \"indicator2\": 32.53\n  }\n]\n\n\nYou request a JSON file using d3.json:\n\nd3.json('https://assets.codepen.io/2814973/my-json.json')\n  .then(function(data) {\n    console.log(data);\n  });\n\nWhen the JSON file arrives, D3 converts it into a JavaScript array or object:\n\n[\n  {\n    \"name\": \"Paris\",\n    \"indicator1\": 4030,\n    \"indicator2\": 13.45\n  },\n  {\n    \"name\": \"Tokyo\",\n    \"indicator1\": 3912,\n    \"indicator2\": 45.41\n  },\n  {\n    \"name\": \"New York\",\n    \"indicator1\": 19481,\n    \"indicator2\": 32.53\n  }\n]\n\nIn this example, the JSON file represents an array, so you can join it to HTML or SVG elements:\n\nfunction update(data) {\n  d3.select('#content tbody')\n    .selectAll('tr')\n    .data(data)\n    .join('tr')\n    .html(function(d) {\n      let html = '<tr>';\n      html += '<td>' + d.name + '</td>';\n      html += '<td>' + d.indicator1 + '</td>';\n      html += '<td>' + d.indicator2 + '</td>';\n      html += '</tr>';\n      return html;\n    });\n}\n\nd3.json('https://assets.codepen.io/2814973/my-json.json')\n  .then(function(data) {\n    update(data);\n  });\n\n\n\n\n\n\n  \n\n\n\n  Unlike CSV data, JSON data isn’t necessarily an array of objects so d3.json doesn’t support row conversion functions.\n\n\nFurther notes\n\nIf the resource has a different domain (e.g. the https://assets.codepen.io part) to your web application, the server might not be willing to fulfil the request due to CORS restrictions. However in this chapter we request files that are free from CORS restrictions.\n\nAnother thing to bear in mind is if you’re developing your code locally (rather than on CodePen or similar) you’ll need to have a local webserver running. If you’re not sure how to do this I recommend reading Fundamentals of HTML, SVG, CSS and JavaScript for Data Visualization.\n\n\n  ",
	"\n  \tD3 transitions let you smoothly animate between different chart states. This article shows how to add transitions to selection updates, how to set transition duration, how to create staggered transitions, how to change the easing function, how to chain transitions and how to create custom tween functions.\n\nFor example, let’s join an array of 5 numbers to SVG circles. When the ‘Update data’ button is clicked, the data is randomised and the circles jump to new positions:\n\n\n\n\n\n\n  \n\n\nIf we add a transition to the circles the circles move smoothly to their new locations:\n\n\n\n\n\n\n  \n\n\nFurthermore, entering circles (circles that have just been created) and exiting circles (circles that are about to be removed) can be transitioned in specific ways. In this example new circles fade in and exiting circles drop down the page:\n\n\n\n\n\n\n  \n\n\nHow to create a D3 transition\n\nCreating a basic transition using D3 is fairly straightforward. Suppose you have the following code which joins an array of random data to circle elements:\n\nlet data = [];\n\nfunction updateData() {\n  data = [];\n  for(let i=0; i<5; i++) {\n    data.push(Math.random() * 800);\n  }\n}\n\nfunction update() {\n  d3.select('svg')\n    .selectAll('circle')\n    .data(data)\n    .join('circle')\n    .attr('cy', 50)\n    .attr('r', 40)\n    .attr('cx', function(d) {\n      return d;\n    });\n}\n\nfunction updateAll() {\n  updateData();\n  update();\n}\n\nupdateAll();\n\n\n  If you’re not familiar with the above code I suggest reading the data joins chapter.\n\n\nThe updateAll function is called when a button is clicked:\n\n<button onClick=\"updateAll();\">Update data</button>\n\nupdateAll calls updateData which randomises the data array. It also calls update which joins data to circle elements.\n\nWhen the button is clicked the circles jump to new locations:\n\n\n\n\n\n\n  \n\n\nYou can then add a .transition() call before the .attr and .style methods that you wish to transition:\n\nfunction update() {\n  d3.select('svg')\n    .selectAll('circle')\n    .data(data)\n    .join('circle')\n    .attr('cy', 50)\n    .attr('r', 40)\n    .transition()\n    .attr('cx', function(d) {\n      return d;\n    });\n}\n\nIn this example, the .transition call is followed by a single .attr call. This results in the cx attribute of the circles transitioning into new positions:\n\n\n\n\n\n\n  \n\n\n\n  The .transition method returns a ‘transition selection’. This is basically the same as a normal D3 selection, except the .attr and .style methods animate attributes and style. A transition selection has additional methods such as .tween which we’ll cover later.\n\n\nOnce the .transition method has been called, subsequent calls to .attr and .style will animate attributes and style, respectively.\n\nFor example, let’s randomise the radius and colour of each circle:\n\n...\n\nfunction random(x) {return Math.floor(Math.random() * x);}\n\nfunction updateData() {\n  data = [];\n  for(let i=0; i<5; i++) {\n    data.push({\n      x: random(800),\n      r: random(40),\n      fill: d3.rgb(random(255), random(255), random(255))\n    });\n  }\n}\n\n...\n\nIn the update function we update the radii and fills after the .transition call:\n\nfunction update() {\n  d3.select('svg')\n    .selectAll('circle')\n    .data(data)\n    .join('circle')\n    .attr('cy', 50)\n    .transition()\n    .attr('cx', function(d) {\n      return d.x;\n    })\n    .attr('r', function(d) {\n      return d.r;\n    })\n    .style('fill', function(d) {\n      return d.fill;\n    });\n}\n\nNow when the data updates, the position, radius and colour of each circle transitions:\n\n\n\n\n\n\n  \n\n\nDuration and delay\n\nYou can change the duration of a transition by calling .duration after the .transition call. The .duration method accepts an argument which specifies the duration in milliseconds:\n\nd3.select('svg')\n  .selectAll('circle')\n  .data(data)\n  .join('circle')\n  .attr('cy', 50)\n  .attr('r', 40)\n  .transition()\n  .duration(2000)\n  .attr('cx', function(d) {\n    return d;\n  });\n\nIn this example we’ve set the duration to 2000 milliseconds:\n\n\n\n\n\n\n  \n\n\nYou can also specify a delay before which the transition starts:\n\n...\n  .transition()\n  .delay(2000)\n  .attr('cx', function(d) {\n    return d;\n  });\n\nThe delay is usually used to delay each element in the selection by a different amount. For example, you can create staggered transitions by passing a function into .delay and setting the delay to a multiple of the element index i:\n\nd3.select('svg')\n  .selectAll('circle')\n  .data(data)\n  .join('circle')\n  .attr('cy', 50)\n  .attr('r', 40)\n  .transition()\n  .delay(function(d, i) {\n    return i * 75;\n  })\n  .attr('cx', function(d) {\n    return d;\n  });\n\n\n\n\n\n\n  \n\n\nEasing functions\n\nAn easing function defines the change in speed of an element during a transition. For example, some easing functions cause the element to start quickly and gradually slow down. Others do the opposite (start slowly and speed up) while others define special effects such as bouncing.\n\nD3 has a number of built in easing functions which you can try out in this explorer:\n\n\n\n\n\n\n  \n\n\n\n  In general ‘in’ refers to the start of the motion and ‘out’ refers to the end of the motion. Therefore, easeBounceOut causes the element to bounce at the end of the transition. easeBounceInOut causes the element to bounce at the start and end of the transition.\n\n\n\n  It’s usually better to use easings where the element moves quickly at first and slows down. For example easeCubicOut is a commonly used easing function where the element moves quickly at first and slows down. D3’s default easing function is easeCubic which is equivalent to easeCubicInOut. This causes the element to start slowly, accelerate, then finish slowly.\n\n\nTo select an easing function use the .ease method and pass in the easing function (e.g. d3.easeBounce):\n\nd3.select('svg')\n  .selectAll('circle')\n  .data(data)\n  .join('circle')\n  .attr('cy', 50)\n  .attr('r', 40)\n  .transition()\n  .ease(d3.easeBounceOut)\n  .attr('cx', function(d) {\n    return d;\n  });\n\n\n\n\n\n\n  \n\n\nChained transitions\n\nTransitions can be chained together by adding multiple calls to .transition. Each transition takes it in turn to proceed. (When the first transition ends, the second one will start, and so on.)\n\nFor example, let’s chain two transitions. The first sets the cx attribute and the second sets the r attribute (and uses easeBounce):\n\nfunction update() {\n  d3.select('svg')\n    .selectAll('circle')\n    .data(data)\n    .join('circle')\n    .attr('cy', 50)\n    .transition()\n    .attr('cx', function(d) {\n      return d.x;\n    })\n    .transition()\n    .duration(750)\n    .ease(d3.easeBounce)\n    .attr('r', function(d) {\n      return d.r;\n    });\n}\n\nWhen the chart updates, the circles move to their new positions, then the radius changes (with a bounce):\n\n\n\n\n\n\n  \n\n\nCustom tweens\n\nIn most circumstances D3 is able to transition attributes and style in a sensible manner. However there are times where the default behaviour might not be suitable.\n\nFor example, suppose we join an array of angle values to circle elements. Each circle is placed on the circumference of a larger circle using the joined value to determine where on the circle it sits. An angle of zero corresponds to 3 o’clock on the large circle.\n\nWhen the data updates, the circles travel in a straight line:\n\n\n\n\n\n\n  \n\n\nYou can customise the path the elements take (such as along the circumference of the large circle) by using a tween function.\n\nTo use a tween function, call the .tween function at some point after .transition. You pass a name (which can be anything you like) and a function into .tween.\n\nThe function gets called once for each element in the selection. It must return a tween function which will get called at each step of the transition. A time value t between 0 and 1 is passed into the tween function. (t is 0 at the beginning of the transition and 1 at the end.)\n\nd3.select('svg g')\n  .selectAll('circle')\n  .data(data)\n  .join('circle')\n  .transition()\n  .tween('my-tween', function(d) {\n    ...\n\n    // Return a tween function\n    return function(t) {\n      // Do stuff here such as updating your HTML/SVG elements\n    }\n  });\n\nTypically you’ll set up interpolator function(s) in the outer function. An interpolator function takes a parameter between 0 and 1 and interpolates between two given values. The interpolator function can be used when updating HTML/SVG elements in the tween function.\n\nFor example:\n\nlet data = [], majorRadius = 100;\n\nfunction updateData() {\n  data = [Math.random() * 2 * Math.PI];\n}\n\nfunction getCurrentAngle(el) {\n  // Compute the current angle from the current values of cx and cy\n  let x = d3.select(el).attr('cx');\n  let y = d3.select(el).attr('cy');\n  return Math.atan2(y, x);\n}\n\nfunction update() {\n  d3.select('svg g')\n    .selectAll('circle')\n    .data(data)\n    .join('circle')\n    .attr('r', 7)\n    .transition()\n    .tween('circumference', function(d) {\n      let currentAngle = getCurrentAngle(this);\n      let targetAngle = d;\n\n      // Create an interpolator function\n      let i = d3.interpolate(currentAngle, targetAngle);\n    \n      return function(t) {\n        let angle = i(t);\n      \n        d3.select(this)\n          .attr('cx', majorRadius * Math.cos(angle))\n          .attr('cy', majorRadius * Math.sin(angle));\n      };\n    });\n}\n\nIn the function that’s passed into .tween we start by computing currentAngle.\n\nWe then set up an interpolator function i. This is a function that interpolates between two values (currentAngle and targetAngle in our case). The function i accepts a number between 0 and 1 and interpolates between the two values.\n\nNext we create a tween function and return it. The tween function uses the interpolator function i to compute angle for the given time value t. It then updates the cx and cy attributes using angle. The tween function is called for each step of the transition.\n\nNow when the button is clicked, the circle moves along the circumference of the large circle. Notice also that when the button is rapidly clicked, the transition starts from the circle’s current (mid-transition) position:\n\n\n\n\n\n\n  \n\n\nEntering and exiting elements\n\nYou can define specific transitions for entering and exiting elements. (Entering elements are newly created elements and exiting elements are ones that are about to be removed.)\n\nFor example you might want entering circles to fade in and exiting circles to fall:\n\n\n\n\n\n\n  \n\n\nTo define enter and exit transitions you need to pass three functions into the .join method. This was covered in the Enter, exit and update chapter so if you’re not familiar with these concepts I suggest you read up on them there.\n\nAs a brief reminder, you can pass three functions (instead of an element name) into the .join method:\n\n.join(\n  function(enter) {\n    ...\n  },\n  function(update) {\n    ...\n  },\n  function(exit) {\n    ...\n  }\n)\n\nThe first, second and third functions are named the enter, update and exit functions, respectively.\n\nEntering elements\n\nAs covered in Enter, exit and update chapter the enter function should append an element to each element of the enter selection.\n\nYou can also set the style and attributes of entering elements and this has the effect of initialising elements before any transitions take place.\n\nLet’s initialise cy, cx, r and opacity on entering circles:\n\n.join(\n  function(enter) {\n    return enter\n      .append('circle')\n      .attr('cy', 50)\n      .attr('cx', function(d) {\n        return d;\n      })\n      .attr('r', 40)\n      .style('opacity', 0);\n  },\n  function(update) {\n    return update;\n  },\n  function(exit) {\n    return exit.remove();\n  }\n)\n\nThe initial x and y coordinates of entering circles are initialised so that the circles appear in place (rather than sliding in from the origin).\n\nThe initial radius of entering circles is initialised so that the circles appear with a radius of 40.\n\nFinally the opacity of entering circles is initialised to 0 so that entering circles fade in. (We’ll set the final opacity later on.)\n\nExiting elements\n\nThe exit function usually removes the elements in the exit selection:\n\n.join(\n  ...\n  function(exit) {\n    return exit.remove();\n  }\n)\n\n\n  If you don’t call .remove on the exit selection, the elements will remain on the page.\n\n\nYou can add a transition to exiting elements by calling .transition on the exit selection. For example, to make exiting elements fall off the page, use .transition and set the cy attribute to a large value:\n\n.join(\n  function(enter) { ... },\n  function(update) { ... },\n  function(exit) {\n    return exit\n      .transition()\n      .attr('cy', 500)\n      .remove();\n  }\n)\n\nThe .remove method of a transition selection removes the selection’s element(s) when the transition ends.\n\nUpdating elements\n\nYou can apply a transition to entering and updating elements by adding a call to .transition after the .join call. This will cause all elements (except exiting elements) to transition.\n\nLet’s add a .transition call and set the cx attribute and the opacity:\n\nd3.select('svg')\n  .selectAll('circle')\n  .data(data)\n  .join(\n    function(enter) { ... },\n    function(update) { ... },\n    function(exit) { ... }\n  )\n  .transition()\n  .attr('cx', function(d) {\n    return d;\n  })\n  .style('opacity', 0.75);\n\nThis has the following effect:\n\n\n  when the data changes, the circles transition to new positions (because of .attr('cx'))\n  when new circles are created, they fade in\n\n\nThe circles fade in because their initial opacity is set to zero in the enter function and the .style call animates the opacity to 0.75.\n\nPutting it all together\n\nHere’s the complete example where:\n\n\n  circles fade in (without sliding or expanding)\n  circles transition to new positions\n  circles fall off the page when they exit\n\n\nd3.select('svg')\n  .selectAll('circle')\n  .data(data)\n  .join(\n    function(enter) {\n      return enter\n        .append('circle')\n        .attr('cy', 50)\n        .attr('cx', function(d) { return d; })\n        .attr('r', 40)\n        .style('opacity', 0);\n    },\n    function(update) {\n      return update;\n    },\n    function(exit) {\n      return exit\n        .transition()\n        .attr('cy', 500)\n        .remove();\n    }\n  )\n  .transition()\n  .attr('cx', function(d) { return d; })\n  .style('opacity', 0.75);\n\n\n\n\n\n\n  \n\n\nTo summarise:\n\n\n  entering elements are initialised in the enter function. This is first function passed into .join. This allows you to initialise style and attributes of entering elements (before the transition starts)\n  a transition is applied to exiting elements in the exit function. This is the third function passed into .join.\n  entering and existing elements are transitioned by adding a call to .transition after .join\n\n\n\n  The update function (the second argument of .join) only updates existing elements (and not entering elements) and I rarely add any special code here.\n\n\n\n  ",
	"\n  \tD3 provides a number of modules that help you add interactivity such as zooming, panning and brushing.\n\nIn this chapter we cover:\n\n\n  quadtree and Delaunay triangulation (to make picking small items easier)\n  dragging (for moving elements)\n  brushing (for selecting regions)\n\n\nZoom and pan are covered in a separate chapter.\n\nQuadtrees\n\nIf your chart contains items sized according to a data variable (such as a bubble chart) hovering over (or clicking) tiny items can be difficult.\n\nTry hovering over the tiny circles:\n\n\n\n\n\n\n  \n\n\nYou can make picking small items easier by searching for the closest item to the mouse pointer each time the mouse is moved. This can be an expensive operation but can be made more efficient using D3’s quadtree module.\n\n\n  A quadtree is a tree data structure that recursively divides an area into smaller and smaller areas and can make searching for items more efficient.\n\n\n\n  Line charts can also benefit from quadtrees for picking points along a line.\n\n\nWith D3’s quadtree module you can create a quadtree, add some points to it, then find the closest point within the quadtree to a given coordinate.\n\nYou can create a quadtree by calling d3.quadtree(). You can then add single points to it using .add:\n\nlet quadtree = d3.quadtree();\n\nquadtree.add([50, 100]);\nquadtree.add([100, 100]);\n\nIn the above example two points have been added: 50, 100 and 100, 100.\n\nGiven a coodinate x, y you can find the nearest point in the quadtree using .find(x, y):\n\nquadtree.find(55, 105); // returns [50, 100]\nquadtree.find(90, 95); // returns [100, 100]\n\nYou can also add a distance (as the third argument) so that only points within that distance are returned:\n\nquadtree.find(60, 100, 20); // returns [50, 100]\nquadtree.find(60, 100, 5); // returns undefined\n\nThe first .find returns [50, 100] because this is the closest point and is within a distance of 20. The second .find returns undefined because the closest point [50, 100] is more than 5 away. This is useful for ensuring the returned point is close to the requested point. Without this constraint, outlier points can get selected even though the pointer isn’t very close.\n\nYou can add an array of points using .addAll:\n\nquadtree.addAll([[10, 50], [60, 30], [80, 20]]);\n\n\n  The .add and .addAll methods are cumulative i.e. the existing quadtree points persist.\n\n\nIf you’ve an array of objects, you can specify accessor functions using the .x and .y methods:\n\nlet data = [\n  { x: 50, y: 100 },\n  { x: 100, y: 100 }\n];\n\nlet quadtree = d3.quadtree()\n  .x(function(d) {return d.x;})\n  .y(function(d) {return d.y;});\n\nquadtree.addAll(data);\n\nquadtree.find(60, 100); // returns {x: 50, y: 100}\n\nExample\n\nLet’s look at an example where we create some randomised points (updateData) and add them to a quadtree (updateQuadtree). We draw the points (update) and set up a mousemove event on the svg element (initEvents).\n\nWhen the mouse moves (see handleMousemove) we search for the nearest point to the mouse pointer using the quadtree. We update hoveredId with the found point’s id then call update again so that the hovered point is coloured red:\n\nlet data = [], width = 600, height = 400, numPoints = 100;\n\nlet quadtree = d3.quadtree()\n  .x(function(d) {return d.x;})\n  .y(function(d) {return d.y;});\n\nlet hoveredId;\n\nfunction updateData() {\n  data = [];\n  for(let i=0; i<numPoints; i++) {\n    data.push({\n      id: i,\n      x: Math.random() * width,\n      y: Math.random() * height,\n      r: 1 + Math.random() * 20\n    });\n  }\n}\n\nfunction handleMousemove(e) {\n  let pos = d3.pointer(e, this);\n  let d = quadtree.find(pos[0], pos[1], 20);\n  hoveredId = d ? d.id : undefined;\n  update();\n}\n\nfunction initEvents() {\n  d3.select('svg')\n    .on('mousemove', handleMousemove);\n}\n\nfunction updateQuadtree() {\n  quadtree.addAll(data);\n}\n\nfunction update() {\n  d3.select('svg')\n    .selectAll('circle')\n    .data(data)\n    .join('circle')\n    .attr('cx', function(d) { return d.x; })\n    .attr('cy', function(d) { return d.y; })\n    .attr('r', function(d) { return d.r; })\n    .style('fill', function(d) { return d.id === hoveredId ? 'red' : null;});\n}\n\nupdateData();\nupdateQuadtree();\nupdate();\ninitEvents();\n\n\n  In handleMousemove we use d3.pointer which given the event object e and an HTML/SVG element, returns the mouse position relative to the HTML/SVG element. In our example, this is the SVG element because this is the element .on was called on (see initEvents).\n\n\nNow your mouse pointer only needs to be within 20 pixels of its nearest circle:\n\n\n\n\n\n\n  \n\n\n\n  D3’s quadtree is also used by d3.forceCollide when detecting collisions in the force layout.\n\n\nDelaunay triangles\n\nYou can also use D3’s Delaunay module for finding closest points. Given an array of points, a Delaunay triangulation connects all the points with triangles in such a way that slivers are minimised.\n\nAs with the quadtree, Delaunay triangles have several uses but we’ll just demonstrate how they can be used to find nearest points.\n\nYou can create Delaunay triangles using the .from method on d3.Delaunay:\n\nlet triangles = d3.Delaunay.from([[50, 100], [100, 100]]);\n\nYou can then search for the nearest point to a coordinate x, y using:\n\nlet i = triangles.find(55, 105); // returns 0\n\nThe .find method returns the array index of the nearest point. Unlike the quadtree, adding a maximum distance as the third argument isn’t supported.\n\nHere’s a full example that uses Delaunay triangulation to find the closest point (click ‘Edit in CodePen’ to view the code):\n\n\n\n\n\n\n  \n\n\nDragging\n\nD3 has a module for adding drag behaviour to elements. Dragging is where you hover over an element, press the mouse button, move the pointer, then release the mouse button, in order to move the element. D3’s drag module also supports touch gestures.\n\n(I rarely need to add drag behaviour to data visualizations so feel free to skip this section if it isn’t important to you!)\n\nThere’s three steps to making HTML/SVG elements draggable:\n\n\n  call d3.drag() to create a drag behaviour function\n  add an event handler that’s called when a drag event occurs. The event handler receives an event object with which you can update the position of the dragged element\n  attach the drag behaviour to the elements you want to make draggable\n\n\nCalling d3.drag() creates a drag behaviour:\n\nlet drag = d3.drag();\n\n\n  A drag behaviour is a function that adds event listeners to elements. It also has methods such as .on defined on it.\n\n\nYou can attach an event handler to the drag behaviour by calling the .on method. This accepts two arguments:\n\n\n  the event type ('drag', 'start' or 'end')\n  the name of your event handler function\n\n\nfunction handleDrag(e) {\n // update the dragged element with its new position\n}\n\nlet drag = d3.drag()\n  .on('drag', handleDrag);\n\n\n  The event types are 'drag', 'start' and 'end'. 'drag' indicates a drag. 'start' indicates the start of the drag (e.g. the user has pressed the mouse button). 'end' indicates the end of the drag (e.g. the user has released the mouse button).\n\n\nhandleDrag receives a single parameter e which is an object representing the drag event. The drag event object has several properties, the most useful of which are:\n\n\n  \n    Property nameDescription\n  \n  .subjectThe joined data of the dragged element (or a fallback object)\n  .x & .yThe new coordinates of the dragged element\n  .dx & .dyThe new coordinates of the dragged element, relative to the previous coordinates\n\n\n\n  You can see a full list of drag event properties in the official documentation.\n\n\nIf the dragged element was created by a data join and the joined data has x and y properties, the x and y properties of the drag event object are computed such that the relative position of the element and pointer are maintained. (This prevents the element’s center ‘snapping’ to the pointer position.) Otherwise x and y are the pointer position relative to the dragged element’s parent element.\n\nYou attach the drag behaviour to elements by selecting the elements and passing the drag behaviour into the .call method.\n\nFor example to add drag behaviour to circle elements:\n\nd3.select('svg')\n  .selectAll('circle')\n  .call(drag);\n\n\n  The drag behaviour is a function that sets up event listeners on the selected elements (each circle element in the above example). When drag events occur the event handler (handleDrag in the above examples) is called.\n\n\nExamples\n\nIn the following code an array of random coordinates is joined to circle elements (updateData and update).\n\nA drag behaviour is created using d3.drag() and attached to the circle elements (initDrag).\n\nWhen a circle is dragged, handleDrag gets called and an event object e is passed in as the first argument. e.subject represents the joined data of the dragged element. The x and y properties of the joined data are updated to e.x and e.y. update is then called to update the circle positions.\n\nlet data = [], width = 600, height = 400, numPoints = 10;\n\nlet drag = d3.drag()\n  .on('drag', handleDrag);\n\nfunction handleDrag(e) {\n  e.subject.x = e.x;\n  e.subject.y = e.y;\n  update();\n}\n\nfunction initDrag() {\n  d3.select('svg')\n    .selectAll('circle')\n    .call(drag);\n}\n\nfunction updateData() {\n  data = [];\n  for(let i=0; i<numPoints; i++) {\n    data.push({\n      id: i,\n      x: Math.random() * width,\n      y: Math.random() * height\n    });\n  }\n}\n\nfunction update() {\n  d3.select('svg')\n    .selectAll('circle')\n    .data(data)\n    .join('circle')\n    .attr('cx', function(d) { return d.x; })\n    .attr('cy', function(d) { return d.y; })\n    .attr('r', 40);\n}\n\nupdateData();\nupdate();\ninitDrag();\n\nNotice that the relative position of the pointer and dragged circle is maintained (try initiating a drag near the edge of a circle):\n\n\n\n\n\n\n  \n\n\nBrushing\n\nBrushing lets you user specify an area (by pressing the mouse button, moving the mouse, then releasing) in order to, for example, select a group of elements.\n\nTry selecting circles by pressing the mouse button, dragging, then releasing the button:\n\n\n\n\n\n\n  \n\n\nD3 has a module for adding brushing behaviour to an element (or, less commonly, multiple elements).\n\nThere’s three steps to adding brush behaviour to an HTML or SVG element:\n\n\n  call d3.brush() to create a brush behaviour function\n  add an event handler that’s called when a brush event occurs. The event handler receives the brush extent which can then be used to select elements, define a zoom area etc.\n  attach the brush behaviour to an element (or elements)\n\n\nCalling d3.brush() creates a brush behaviour:\n\nlet brush = d3.brush();\n\n\n  A brush behaviour is a function that has methods such as .on defined on it. The function itself adds event listeners to an element as well as additional elements (mainly rect elements) for rendering the brush extent.\n\n\nYou can attach an event handler to a brush behaviour by calling the .on method. This accepts two arguments:\n\n\n  the event type ('brush', 'start' or 'end')\n  the name of your event handler function\n\n\nfunction handleBrush(e) {\n // get the brush extent and use it to, for example, select elements\n}\n\nlet brush = d3.brush()\n  .on('brush', handleBrush);\n\n\n  The event types are 'brush', 'start' and 'end'. 'brush' indicates that the brush extent has changed. 'start' indicates the brushing has started (e.g. the user has pressed the mouse button). 'end' indicates the end of brushing (e.g. the user has released the mouse button).\n\n\nhandleBrush receives a single parameter e which is an object representing the brush event. The most useful property on the brush event is .selection which represents the extent of the brush as an array [[x0, y0], [x1, y1]] where x0, y0 and x1, y1 are the opposite corners of the brush. Typically handleBrush will compute which elements are within the brush extent and update them accordingly.\n\nYou attach the brush behaviour to an element by selecting the element and passing the brush behaviour into the .call method:\n\nd3.select('svg')\n  .call(brush);\n\nExamples\n\nBasic example\n\nIn the following example a brush is created using d3.brush(). An event handler handleBrush is added to the brush behaviour using the .on method.\n\nhandleBrush gets called whenever brushing starts (the 'start' event type) or the brush extent changes (the 'brush' event type).\n\nThe brush behaviour is attached to the svg element by calling .call and passing in the brush behaviour (see initBrush).\n\nlet brush = d3.brush()\n  .on('start brush', handleBrush);\n\nfunction handleBrush(e) {\n  // Use the brush extent e.selection to compute, for example, which elements to select\n}\n\nfunction initBrush() {\n  d3.select('svg')\n    .call(brush);\n}\n\ninitBrush();\n\nFull example\n\nHere’s a complete example where an array of random coordinates is joined to circle elements (updateData and update). When the brush is active, the circles within the brush extent are coloured red.\n\nThe brush is initialised in initBrush. (Note that it’s attached to a g element within the svg element, in order to keep the elements used to render the brush separate to the circles.)\n\nWhen brushing occurs, handleBrush is called. This receives a brush event object e which has a property selection that defines the extent of the brush. This is saved to the variable brushExtent and update is called.\n\nupdate performs the data join and colours circles red if they’re within the extent defined by brushExtent (see isInBrushExtent):\n\nlet data = [], width = 600, height = 400, numPoints = 100;\n\nlet brush = d3.brush()\n  .on('start brush', handleBrush);\n\nlet brushExtent;\n\nfunction handleBrush(e) {\n  brushExtent = e.selection;\n  update();\n}\n\nfunction initBrush() {\n  d3.select('svg g')\n    .call(brush);\n}\n\nfunction updateData() {\n  data = [];\n  for(let i=0; i<numPoints; i++) {\n    data.push({\n      id: i,\n      x: Math.random() * width,\n      y: Math.random() * height\n    });\n  }\n}\n\nfunction isInBrushExtent(d) {\n  return brushExtent &&\n    d.x >= brushExtent[0][0] &&\n    d.x <= brushExtent[1][0] &&\n    d.y >= brushExtent[0][1] &&\n    d.y <= brushExtent[1][1];\n}\n\nfunction update() {\n  d3.select('svg')\n    .selectAll('circle')\n    .data(data)\n    .join('circle')\n    .attr('cx', function(d) { return d.x; })\n    .attr('cy', function(d) { return d.y; })\n    .attr('r', 4)\n    .style('fill', function(d) {\n      return isInBrushExtent(d) ? 'red' : null;\n    });\n}\n\ninitBrush();\nupdateData();\nupdate();\n\n\n\n\n\n\n  \n\n\nOne dimensional brushes\n\nD3 also provides brushes d3.brushX and d3.brushY that constrain the brush to a single dimension.\n\nThey work in a simlar fashion to d3.brush, the main difference being the event object’s .selection property which is an array of two numbers [min, max] which represent the extent of the brush.\n\nHere’s an example using d3.brushX:\n\n\n\n\n\n\n  \n\n\nProgrammatic control of brushing\n\nYou can also set the brush extent programmatically. For example you can create a button that sets the brush to maximum size.\n\nThe brush behaviour has two methods for setting the brush extent .move and .clear. The first sets the brush extent to [[x0, y0], [x1, y1]] and the second clears the brush.\n\n.move and .clear should be called on the element that receives the brush gestures. For example:\n\nd3.select('svg g')\n  .call(brush.move, [[50, 50], [100, 100]]);\n\nHere’s an example that has two buttons. One button sets the brush extent to the size of the svg element and the other button clears the brush:\n\n\n\n\n\n\n  \n\n\n\n  ",
	"\n  \tD3 provides a module ‘d3.zoom’ that adds zoom and pan behaviour to an HTML or SVG element. This article shows how to create zoom behaviours, how to add zoom and pan constraints and how to zoom and pan programmatically.\n\nD3 can add zoom and pan behaviour to an HTML or SVG element. In the following example, click and move the mouse to pan and use the mouse wheel to zoom. Touch gestures should also work:\n\n\n\n\n\n\n  \n\n\nWhen zoom and pan gestures (such as dragging or a pinch gesture) occur, a transform (consisting of scale and translate) is computed by D3 and passed into an event handler. The event handler typically applies the transform to chart elements.\n\nThere’s three steps to add zoom and pan behaviour to an element:\n\n\n  call d3.zoom() to create a zoom behaviour function\n  add an event handler that gets called when a zoom or pan event occurs. The event handler receives a transform which can be applied to chart elements\n  attach the zoom behaviour to an element that receives the zoom and pan gestures\n\n\nIt’s helpful to distinguish between the HTML or SVG element that receives the zoom and pan gestures and the elements that get zoomed and panned (the elements that get transformed). It’s important that these elements are different, otherwise the panning won’t work properly.\n\nCalling d3.zoom() creates a zoom behaviour:\n\nlet zoom = d3.zoom();\n\n\n  Although it’s called d3.zoom, this module handles zoom and pan events.\n\n\n\n  A zoom behaviour is a function that adds event handlers (for drags, mouse wheel events and touch events etc.) to an element. It also has methods such as .on defined on it.\n\n\nYou can attach an event handler to your zoom behaviour by calling the .on method. This accepts two arguments:\n\n\n  the event type ('zoom', 'start' or 'end')\n  the name of your event handler function\n\n\nfunction handleZoom(e) {\n // apply transform to the chart\n}\n\nlet zoom = d3.zoom()\n  .on('zoom', handleZoom);\n\n\n  The event types are 'zoom', 'start' and 'end'. 'zoom' indicates a change of transform (e.g. the user has zoomed or panned). 'start' indicates the start of the zoom or pan (e.g. the user has pressed the mouse button). 'end' indicates the end of the zoom or pan (e.g. the user has released the mouse button).\n\n\nhandleZoom receives a single parameter e which is an object representing the zoom event. The most useful property on this object is transform. This is an object that represents the latest zoom transform and is typically applied to the chart element(s):\n\nfunction handleZoom(e) {\n  d3.select('g.chart')\n    .attr('transform', e.transform);\n}\n\n\n  e.transform has three properties x, y and k. x and y specify the translate transform and k represents the scale factor. It also has a .toString method which generates a string such as \"translate(38.9,-4.1) scale(1.3)\". This means you can pass e.transform directly into .attr.\n\n\nYou attach the zoom behaviour to an element by selecting the element and passing the zoom behaviour into the .call method:\n\nd3.select('svg')\n  .call(zoom);\n\n\n  The zoom behaviour is a function that sets up event listeners on the selected element (svg in the above example). When zoom and pan events occur, a transform is computed and passed into the event handler (handleZoom in the above examples).\n\n\nExample\n\nSuppose you have an SVG element that contains a g element:\n\n<svg width=\"600\" height=\"400\">\n  <g></g>\n</svg>\n\nIn the following code a zoom behaviour is created using d3.zoom() and attached to the svg element.\n\nhandleZoom is passed into the .on method. When a zoom or pan occurs, handleZoom gets called. This applies the transform e.transform to the g element.\n\nfunction handleZoom(e) {\n  d3.select('svg g')\n    .attr('transform', e.transform);\n}\n\nlet zoom = d3.zoom()\n  .on('zoom', handleZoom);\n\nd3.select('svg')\n  .call(zoom);\n\nHere’s a full example where an array of random coordinates is joined to circle elements:\n\nlet data = [], width = 600, height = 400, numPoints = 100;\n\nlet zoom = d3.zoom()\n  .on('zoom', handleZoom);\n\nfunction handleZoom(e) {\n  d3.select('svg g')\n    .attr('transform', e.transform);\n}\n\nfunction initZoom() {\n  d3.select('svg')\n    .call(zoom);\n}\n\nfunction updateData() {\n  data = [];\n  for(let i=0; i<numPoints; i++) {\n    data.push({\n      id: i,\n      x: Math.random() * width,\n      y: Math.random() * height\n  \t});\n  }\n}\n\nfunction update() {\n  d3.select('svg g')\n    .selectAll('circle')\n    .data(data)\n    .join('circle')\n    .attr('cx', function(d) { return d.x; })\n    .attr('cy', function(d) { return d.y; })\n    .attr('r', 3);\n}\n\ninitZoom();\nupdateData();\nupdate();\n\nUse the mouse wheel and dragging, or touch gestures, to zoom and pan the circles:\n\n\n\n\n\n\n  \n\n\nZoom and pan constraints\n\nYou can constrain the zoom and pan so that the user can only zoom and pan within specified bounds.\n\nThe zoom can be constrained using .scaleExtent into which you pass an array [min, max] where min is the minimum scale factor and max is the maximum scale factor:\n\nlet zoom = d3.zoom()\n  .scaleExtent([1, 5]);\n\nYou can use .translateExtent to specify bounds [[x0, y0], [x1, y1]] that the user can’t pan outside of:\n\nlet width = 600, height = 400;\n\nlet zoom = d3.zoom()\n  .scaleExtent([1, 5])\n  .translateExtent([[0, 0], [width, height]]);\n\nNow you can only zoom in up to a scale factor of 5. Neither can you zoom out beyond the default scale factor of 1. In addition you cannot pan beyond the bounds of the chart:\n\n\n\n\n\n\n  \n\n\nProgrammatic zoom control\n\nYou can also zoom and pan programmatically. For example you can create buttons that zoom the chart when clicked.\n\nThe zoom behaviour has the following methods for setting the zoom and pan programmatically:\n\n\n  \n    Method nameDescription\n  \n  .translateByadds a given x, y offset to the current transform\n  .translateTosets the transform such that a given x, y coordinate is centered (or positioned on a given point [px, py])\n  .scaleBymultiplies the current scale factor by a given value\n  .scaleTosets the scale factor to a given value\n  .transformsets the transform to a given transform. (Use d3.zoomIdentity to create a zoom transform.)\n\n\nThe above methods shouldn’t be called directly. Instead, they should be called on the element that receives the zoom and pan gestures. For example:\n\nd3.select('svg')\n  .call(zoom.scaleBy, 0.5);\n\nYou can also call these methods on a transition selection, which results in nice effects:\n\nd3.select('svg')\n  .transition()\n  .call(zoom.translateBy, 50, 0);\n\nHere’s a full example using a few of the above methods:\n\n\n\n\n\n\n  \n\n\n\n  "
]